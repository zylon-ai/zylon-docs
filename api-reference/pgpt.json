{
  "openapi": "3.1.0",
  "info": {
    "title": "Zylon-GPT API",
    "description": "\nThis API describes Zylon's AI layer's API. The API exposes low-level\nprimitives that allow developers to build AI apps\nand worflows on top of Zylon's Private AI platform.\n",
    "version": "0.73.2\n"
  },
  "servers": [
    {
      "url": "https://{base_url}/gpt",
      "description": "Your Zylon instance (replace {base_url} with your actual hostname)"
    }
  ],
  "paths": {
    "/v1/messages": {
      "post": {
        "tags": [
          "Messages",
          "Messages"
        ],
        "summary": "Messages",
        "description": "Generate a chat completion from a conversation history.\n\nThis endpoint enables multi-turn conversations with the AI model, with\noptional tool support and comprehensive message validation.\n\nKey Features:\n* Multi-turn conversations: Support for system, user, and assistant\n  messages\n* Tool Support: Full tool use/result validation with automatic or manual\n  selection\n* Citations: Enable `system.citations.enabled` to include references in\n  responses\n* Streaming: Enable `stream` for partial updates in real-time\n* Default Prompts: Enable `system.use_default_prompt` for using Zylon\n  prompts\n* Thinking: Enable `thinking.enabled` for step-by-step reasoning\n  capabilities\n* Sampling Parameters: Control randomness with temperature, top_p,\n  top_k, etc.\n\nNotes:\n* Tool use/result blocks must be properly paired within assistant\n  messages\n* Tool choice type must be 'auto', 'tool', or 'none'\n* When tool_choice.type is 'tool', tool_choice.name must specify a\n  valid tool\n* All message content is validated for completeness and proper structure\n* Last message must be from user or assistant for proper conversation\n  flow\n* MCP servers provide external tool capabilities via Model Context\n  Protocol\n* Sampling parameters control response randomness and token selection",
        "operationId": "chat_messages_v1_messages_post",
        "requestBody": {
          "description": "Request body for chat completion supporting multi-turn conversations with AI models.\n\nContains message history, tool definitions, system prompts, and response configuration. Supports both streaming and non-streaming responses with optional tool usage, citations, and advanced sampling parameters.\n\nThe request body defines the complete conversation context and AI behavior parameters for generating responses.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful chat message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MessageOutput"
                },
                "examples": {
                  "text_response": {
                    "summary": "Standard text response",
                    "value": {
                      "id": "msg_12345",
                      "type": "message",
                      "role": "assistant",
                      "content": [
                        {
                          "type": "text",
                          "start_timestamp": "2025-07-10T09:11:16.003615Z",
                          "stop_timestamp": "2025-07-10T09:11:28.048942Z",
                          "text": "Based on the analysis, I found 3 potential security issues..."
                        }
                      ],
                      "model": "private-gpt",
                      "stop_reason": "end_turn",
                      "usage": {
                        "input_tokens": 432,
                        "output_tokens": 89
                      }
                    }
                  },
                  "tool_use_response": {
                    "summary": "Response with tool usage",
                    "value": {
                      "id": "msg_67890",
                      "type": "message",
                      "role": "assistant",
                      "content": [
                        {
                          "type": "text",
                          "text": "I'll help you with precise temperature control."
                        },
                        {
                          "type": "tool_use",
                          "id": "scan_001",
                          "name": "security_scanner",
                          "input": {
                            "directory": "/src",
                            "scan_type": "vulnerability"
                          }
                        }
                      ],
                      "model": "private-gpt",
                      "stop_reason": "tool_use",
                      "usage": {
                        "input_tokens": 156,
                        "output_tokens": 234
                      }
                    }
                  },
                  "tool_use_and_result_response": {
                    "summary": "Response with tool usage and result",
                    "value": {
                      "id": "msg_67890",
                      "type": "message",
                      "role": "assistant",
                      "content": [
                        {
                          "type": "text",
                          "text": "I'll help you with precise temperature control."
                        },
                        {
                          "type": "tool_use",
                          "id": "scan_001",
                          "name": "security_scanner",
                          "input": {
                            "directory": "/src",
                            "scan_type": "vulnerability"
                          }
                        },
                        {
                          "type": "tool_result",
                          "tool_use_id": "scan_001",
                          "content": [
                            {
                              "type": "text",
                              "start_timestamp": "2025-07-10T09:11:40.123456Z",
                              "stop_timestamp": "2025-07-10T09:11:45.654321Z",
                              "text": "Scan complete. Found 3 vulnerabilities in /src."
                            }
                          ]
                        },
                        {
                          "type": "text",
                          "text": "Based on the scan results, you should address the vulnerabilities found in /src..."
                        }
                      ],
                      "model": "private-gpt",
                      "stop_reason": "end_turn",
                      "usage": {
                        "input_tokens": 156,
                        "output_tokens": 324
                      }
                    }
                  }
                }
              },
              "text/event-stream": {
                "examples": {
                  "streaming_response": {
                    "summary": "Server-sent events for streaming",
                    "value": "event: message_start\ndata: {\"type\":\"message_start\",\"message\":{\"id\":\"msg_12345\",\"type\":\"message\",\"role\":\"assistant\",\"content\":[],\"model\":\"private-gpt\",\"usage\":{}}}\n\nevent: content_block_start\ndata: {\"type\":\"content_block_start\",\"block_id\":\"block_001\",\"content_block\":{\"type\":\"text\",\"start_timestamp\":\"2025-07-10T09:12:41.819953Z\",\"text\":\"\"}}\n\nevent: content_block_delta\ndata: {\"type\":\"content_block_delta\",\"block_id\":\"block_001\",\"delta\":{\"type\":\"text_delta\",\"text\":\"Analyzing your codebase\"}}\n\nevent: content_block_stop\ndata: {\"type\":\"content_block_stop\",\"stop_timestamp\":\"2025-07-10T09:12:54.044672Z\",\"block_id\":\"block_001\"}\n\nevent: message_delta\ndata: {\"type\":\"message_delta\",\"delta\":{\"stop_reason\":\"end_turn\"},\"usage\":{\"input_tokens\":432,\"output_tokens\":89}}\n\nevent: message_stop\ndata: {\"type\":\"message_stop\"}\n\n"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "empty_messages": {
                    "summary": "Empty messages array",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "messages"
                          ],
                          "msg": "Messages cannot be empty",
                          "type": "value_error"
                        }
                      ]
                    }
                  },
                  "invalid_tool_choice": {
                    "summary": "Invalid tool choice",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "tool_choice"
                          ],
                          "msg": "Tool choice 'nonexistent_tool' is not in the provided tools",
                          "type": "value_error"
                        }
                      ]
                    }
                  },
                  "json_schema_with_tools": {
                    "summary": "JSON schema incompatible with tools",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body"
                          ],
                          "msg": "Tools are not supported when response_format is set to json_schema",
                          "type": "value_error"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/messages/validate": {
      "post": {
        "tags": [
          "Messages",
          "Messages"
        ],
        "summary": "Validate Messages Request",
        "description": "Validate a chat completion request without executing it.\n\nThis endpoint performs a dry-run validation of the chat request,\nchecking for:\n\n* Message structure and content validation\n* Tool definitions and tool_choice compatibility\n* Parameter ranges and combinations\n* Conversation flow and message ordering\n* Response format compatibility with other options\n\nReturns detailed validation results including errors. Use this endpoint to\nvalidate requests before sending them to the main chat endpoint.\n\nNotes:\n* No tokens are consumed during validation\n* All validation rules match the main /messages endpoint\n* Warnings indicate potential issues but don't prevent execution\n* Request summary provides insights into the parsed request structure",
        "operationId": "validate_messages_v1_messages_validate_post",
        "requestBody": {
          "description": "Request body for chat completion supporting multi-turn conversations with AI models.\n\nContains message history, tool definitions, system prompts, and response configuration. Supports both streaming and non-streaming responses with optional tool usage, citations, and advanced sampling parameters.\n\nThe request body defines the complete conversation context and AI behavior parameters for generating responses.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Validation completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatValidationResult"
                },
                "examples": {
                  "valid_request": {
                    "summary": "Valid request example",
                    "value": {
                      "valid": true,
                      "errors": [],
                      "warnings": [],
                      "request_summary": {
                        "message_count": 3,
                        "has_tools": true,
                        "stream_enabled": false,
                        "tool_choice": "auto"
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "400": {
            "description": "Validation completed",
            "content": {
              "application/json": {
                "examples": {
                  "invalid_request": {
                    "summary": "Invalid request example",
                    "value": {
                      "valid": false,
                      "errors": [
                        "Messages cannot be empty",
                        "Tool choice 'nonexistent_tool' is not in the provided tools"
                      ]
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Request body validation error",
            "content": {
              "application/json": {
                "examples": {
                  "malformed_request": {
                    "summary": "Malformed request body",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "messages"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/messages/async": {
      "post": {
        "tags": [
          "Async Messages"
        ],
        "summary": "Initiate Async Chat Stream",
        "description": "Initiate an asynchronous chat completion stream.\n\nThis endpoint starts an asynchronous chat completion process that streams\nevents. Unlike synchronous chat, this endpoint returns immediately\nwith a message_id that can be used to observe the stream progress.\n\nKey Features:\n* Asynchronous Processing: Non-blocking request handling with immediate response\n* Stream Observation: Use returned message_id to observe real-time events\n* Works exactly like synchronous chat, but in an async manner\n\nNotes:\n* Optional message_id query parameter for custom stream identification\n* Stream events follow the same format as synchronous chat responses\n* Stream status can be monitored via status endpoint",
        "operationId": "chat_messages_v1_messages_async_post",
        "parameters": [
          {
            "name": "message_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional custom identifier for the stream. If not provided, a unique ID will be generated automatically.",
              "title": "Message Id"
            },
            "description": "Optional custom identifier for the stream. If not provided, a unique ID will be generated automatically.",
            "example": "custom_msg_12345"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatBody"
              }
            }
          },
          "description": "Request body for initiating asynchronous chat completion with multi-turn conversation support.\n\nContains message history, tool definitions, system prompts, and response configuration. The request initiates a background process that streams events, which can be observed via the stream endpoint.\n\nThe request body defines the complete conversation context and AI behavior parameters for generating asynchronous responses."
        },
        "responses": {
          "200": {
            "description": "Chat stream initiated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatResponse"
                },
                "examples": {
                  "stream_initiated": {
                    "summary": "Stream initiated successfully",
                    "value": {
                      "message_id": "msg_async_12345",
                      "status": "pending",
                      "message": "Request initiated successfully"
                    }
                  },
                  "stream_with_custom_id": {
                    "summary": "Stream initiated with custom message_id",
                    "value": {
                      "message_id": "custom_msg_67890",
                      "status": "pending",
                      "message": "Request initiated successfully"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "empty_messages": {
                    "summary": "Empty messages array",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "messages"
                          ],
                          "msg": "Messages cannot be empty",
                          "type": "value_error"
                        }
                      ]
                    }
                  },
                  "invalid_tool_choice": {
                    "summary": "Invalid tool choice",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "tool_choice"
                          ],
                          "msg": "Tool choice 'nonexistent_tool' is not in the provided tools",
                          "type": "value_error"
                        }
                      ]
                    }
                  },
                  "json_schema_with_tools": {
                    "summary": "JSON schema incompatible with tools",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body"
                          ],
                          "msg": "Tools are not supported when response_format is set to json_schema",
                          "type": "value_error"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/messages/async/{message_id}/stream": {
      "get": {
        "tags": [
          "Async Messages"
        ],
        "summary": "Observe Async Chat Stream Events",
        "description": "Observe an asynchronous chat stream via Server-Sent Events.\n\nThis endpoint provides a Server-Sent Events stream that delivers\nchat completion events in real-time. The events follow\nthe same format as synchronous chat streaming responses.\n\nStream Lifecycle:\n1. Stream initiated via POST /v1/messages/async\n2. Events begin flowing when processing starts\n3. Stream automatically closes when message completes\n4. Stream can be cancelled via POST /v1/messages/async/{message_id}/cancel\n\nNotes:\n* Stream remains active until message completion or cancellation\n* Events are delivered in chronological order\n* Connection will automatically close when stream ends\n* Use appropriate SSE client libraries for robust event handling",
        "operationId": "observe_stream_v1_messages_async__message_id__stream_get",
        "parameters": [
          {
            "name": "message_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Message ID of the asynchronous chat stream to observe. ",
              "title": "Message Id"
            },
            "description": "Message ID of the asynchronous chat stream to observe. ",
            "example": "custom_msg_12345"
          }
        ],
        "responses": {
          "200": {
            "description": "Server-sent events stream with chat completion data",
            "content": {
              "application/json": {
                "schema": {}
              },
              "text/event-stream": {
                "examples": {
                  "async_streaming_response": {
                    "summary": "Server-sent events for async streaming",
                    "value": "event: message_start\ndata: {\"type\":\"message_start\",\"message\":{\"id\":\"msg_async_12345\",\"type\":\"message\",\"role\":\"assistant\",\"content\":[],\"model\":\"private-gpt\",\"usage\":{}}}\n\nevent: content_block_start\ndata: {\"type\":\"content_block_start\",\"block_id\":\"block_001\",\"content_block\":{\"type\":\"text\",\"start_timestamp\":\"2025-07-10T09:12:41.819953Z\",\"text\":\"\"}}\n\nevent: content_block_delta\ndata: {\"type\":\"content_block_delta\",\"block_id\":\"block_001\",\"delta\":{\"type\":\"text_delta\",\"text\":\"Processing your request asynchronously\"}}\n\nevent: content_block_stop\ndata: {\"type\":\"content_block_stop\",\"stop_timestamp\":\"2025-07-10T09:12:54.044672Z\",\"block_id\":\"block_001\"}\n\nevent: message_delta\ndata: {\"type\":\"message_delta\",\"delta\":{\"stop_reason\":\"end_turn\"},\"usage\":{\"input_tokens\":432,\"output_tokens\":89}}\n\nevent: message_stop\ndata: {\"type\":\"message_stop\"}\n\n"
                  },
                  "async_tool_use_stream": {
                    "summary": "Async streaming with tool usage",
                    "value": "event: message_start\ndata: {\"type\":\"message_start\",\"message\":{\"id\":\"msg_async_67890\",\"type\":\"message\",\"role\":\"assistant\",\"content\":[],\"model\":\"private-gpt\",\"usage\":{}}}\n\nevent: content_block_start\ndata: {\"type\":\"content_block_start\",\"block_id\":\"block_001\",\"content_block\":{\"type\":\"text\",\"text\":\"\"}}\n\nevent: content_block_delta\ndata: {\"type\":\"content_block_delta\",\"block_id\":\"block_001\",\"delta\":{\"type\":\"text_delta\",\"text\":\"I'll help you with that task.\"}}\n\nevent: content_block_stop\ndata: {\"type\":\"content_block_stop\",\"block_id\":\"block_001\"}\n\nevent: content_block_start\ndata: {\"type\":\"content_block_start\",\"block_id\":\"block_002\",\"content_block\":{\"type\":\"tool_use\",\"id\":\"tool_001\",\"name\":\"security_scanner\",\"input\":{}}}\n\nevent: content_block_delta\ndata: {\"type\":\"content_block_delta\",\"block_id\":\"block_002\",\"delta\":{\"type\":\"input_json_delta\",\"partial_json\":\"{\\\"directory\\\":\\\"/src\\\"}\"}}\n\nevent: content_block_stop\ndata: {\"type\":\"content_block_stop\",\"block_id\":\"block_002\"}\n\nevent: message_delta\ndata: {\"type\":\"message_delta\",\"delta\":{\"stop_reason\":\"tool_use\"},\"usage\":{\"input_tokens\":156,\"output_tokens\":67}}\n\nevent: message_stop\ndata: {\"type\":\"message_stop\"}\n\n"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Stream not found",
            "content": {
              "application/json": {
                "examples": {
                  "stream_not_found": {
                    "summary": "Stream does not exist",
                    "value": {
                      "detail": "Stream with message_id msg_nonexistent not found"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/messages/async/{message_id}/status": {
      "get": {
        "tags": [
          "Async Messages"
        ],
        "summary": "Get Async Chat Stream Status",
        "description": "Get the current status and metadata of an asynchronous chat stream.\n\nThis endpoint returns comprehensive information about a chat stream's\ncurrent state, including processing status, timestamps, error information,\nand additional metadata collected during processing.\n\nStatus Values:\n* pending: Stream created but processing not yet started\n* processing: Active processing with events being generated\n* completed: Stream finished successfully\n* cancelled: Stream was cancelled by user request\n* error: Stream encountered an error and stopped\n\nUse Cases:\n* Monitor stream progress without consuming events\n* Check completion status before attempting to observe\n* Debugging failed streams via error messages\n* Performance monitoring through metadata",
        "operationId": "get_stream_status_v1_messages_async__message_id__status_get",
        "parameters": [
          {
            "name": "message_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Message ID of the asynchronous chat stream to check status for. ",
              "title": "Message Id"
            },
            "description": "Message ID of the asynchronous chat stream to check status for. ",
            "example": "custom_msg_12345"
          }
        ],
        "responses": {
          "200": {
            "description": "Stream status and metadata information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StreamMetadata"
                },
                "examples": {
                  "pending_stream": {
                    "summary": "Stream in pending state",
                    "value": {
                      "message_id": "msg_async_12345",
                      "status": "pending",
                      "created_at": "2025-07-10T09:11:16.003615Z",
                      "updated_at": "2025-07-10T09:11:16.003615Z",
                      "stream_type": "default",
                      "metadata": {}
                    }
                  },
                  "processing_stream": {
                    "summary": "Stream currently processing",
                    "value": {
                      "message_id": "msg_async_67890",
                      "status": "processing",
                      "created_at": "2025-07-10T09:11:16.003615Z",
                      "updated_at": "2025-07-10T09:11:20.123456Z",
                      "stream_type": "default",
                      "metadata": {
                        "tokens_processed": 156,
                        "tools_used": [
                          "security_scanner"
                        ]
                      }
                    }
                  },
                  "completed_stream": {
                    "summary": "Successfully completed stream",
                    "value": {
                      "message_id": "msg_async_99999",
                      "status": "completed",
                      "created_at": "2025-07-10T09:11:16.003615Z",
                      "updated_at": "2025-07-10T09:11:28.987654Z",
                      "completed_at": "2025-07-10T09:11:28.987654Z",
                      "stream_type": "default",
                      "metadata": {
                        "total_tokens": 521,
                        "completion_time_ms": 12984
                      }
                    }
                  },
                  "error_stream": {
                    "summary": "Stream encountered an error",
                    "value": {
                      "message_id": "msg_async_error",
                      "status": "error",
                      "created_at": "2025-07-10T09:11:16.003615Z",
                      "updated_at": "2025-07-10T09:11:18.555555Z",
                      "error_message": "Tool execution timeout after 30 seconds",
                      "stream_type": "default",
                      "metadata": {
                        "error_code": "TOOL_TIMEOUT",
                        "failed_tool": "security_scanner"
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Stream not found",
            "content": {
              "application/json": {
                "examples": {
                  "status_not_found": {
                    "summary": "Stream status not available",
                    "value": {
                      "detail": "Stream with message_id msg_nonexistent not found"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/messages/async/{message_id}/cancel": {
      "post": {
        "tags": [
          "Async Messages"
        ],
        "summary": "Cancel Async Chat Stream",
        "description": "Cancel an active asynchronous chat stream.\n\nThis endpoint gracefully cancels an ongoing chat completion stream by:\n1. Setting the cancellation token to stop the event generation loop\n2. Cancelling the underlying asyncio task\n3. Updating the stream status to 'cancelled'\n\nNotes:\n* Cancellation is irreversible - stream cannot be resumed\n* Any active SSE connections will receive a final event and close\n* Stream status will be updated to reflect cancellation\n* Use DELETE endpoint to remove cancelled streams from storage",
        "operationId": "cancel_stream_v1_messages_async__message_id__cancel_post",
        "parameters": [
          {
            "name": "message_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Message ID of the asynchronous chat stream to cancel. ",
              "title": "Message Id"
            },
            "description": "Message ID of the asynchronous chat stream to cancel. ",
            "example": "custom_msg_12345"
          }
        ],
        "responses": {
          "200": {
            "description": "Stream cancelled successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatCancellationResponse"
                },
                "examples": {
                  "cancellation_success": {
                    "summary": "Stream cancelled successfully",
                    "value": {
                      "message": "Stream cancelled successfully",
                      "message_id": "msg_async_12345"
                    }
                  },
                  "cancellation_with_cleanup": {
                    "summary": "Stream cancelled with cleanup",
                    "value": {
                      "message": "Stream cancelled successfully",
                      "message_id": "msg_async_long_running"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Stream not found",
            "content": {
              "application/json": {
                "examples": {
                  "cancel_not_found": {
                    "summary": "Cannot cancel non-existent stream",
                    "value": {
                      "detail": "Stream with message_id msg_nonexistent not found"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {},
                "additionalProperties": false
              }
            }
          },
          "required": false,
          "description": "Empty request body for stream cancellation. No additional parameters are required to cancel a stream."
        }
      }
    },
    "/v1/messages/async/{message_id}/delete": {
      "delete": {
        "tags": [
          "Async Messages"
        ],
        "summary": "Delete Async Chat Stream",
        "description": "Delete an asynchronous chat stream and clean up all associated resources.\n\nThis endpoint permanently removes a chat stream from storage and cleans\nup all associated resources including:\n* Stream metadata and status information\n* Cached events and message content\n* Task references and cancellation tokens\n\nNotes:\n* Stream must exist to be deleted (returns 404 otherwise)\n* Active streams are automatically cancelled before deletion\n* No response body returned on successful deletion (204 status)\n* Use status endpoint to verify deletion if needed",
        "operationId": "delete_stream_v1_messages_async__message_id__delete_delete",
        "parameters": [
          {
            "name": "message_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Message ID of the asynchronous chat stream to delete. ",
              "title": "Message Id"
            },
            "description": "Message ID of the asynchronous chat stream to delete. ",
            "example": "custom_msg_12345"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "204": {
            "description": "Stream deleted successfully - no content returned"
          },
          "404": {
            "description": "Stream not found",
            "content": {
              "application/json": {
                "examples": {
                  "delete_not_found": {
                    "summary": "Cannot delete non-existent stream",
                    "value": {
                      "detail": "Stream with message_id msg_nonexistent not found"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/embeddings": {
      "post": {
        "tags": [
          "Embeddings",
          "Embeddings"
        ],
        "summary": "Generate embeddings for text input",
        "description": "Generate vector embeddings from input text.\n\nThis endpoint converts text into high-dimensional vector representations\nthat capture semantic meaning. These embeddings preserve semantic\nrelationships between texts and can be used for various machine learning\ntasks.\n\nNotes:\n* Empty strings or arrays are not accepted\n* Results include index numbers for mapping back to original inputs\n* All embeddings are generated as query vectors. If the embeddings have two modes\n(e.g., query and document), this endpoint only returns query vectors.",
        "operationId": "embeddings_generation_v1_embeddings_post",
        "requestBody": {
          "description": "Request body for generating vector embeddings from text.\n\nContains input text(s) to be converted into high-dimensional vector representations. Supports both single string input and batch processing with arrays of strings for efficient embedding generation.\n\nThe request body defines text input and processing options for generating semantic embeddings that capture meaning and relationships between texts.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingsBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successfully generated embeddings",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmbeddingsResponse"
                },
                "examples": {
                  "single_text_embedding": {
                    "summary": "Embedding for single text input",
                    "value": {
                      "object": "list",
                      "model": "private-gpt",
                      "data": [
                        {
                          "index": 0,
                          "object": "embedding",
                          "embedding": [
                            0.123,
                            -0.456,
                            0.789,
                            0.234,
                            -0.567,
                            0.891,
                            -0.123,
                            0.445,
                            -0.678,
                            0.901
                          ]
                        }
                      ]
                    }
                  },
                  "multiple_text_embeddings": {
                    "summary": "Embeddings for multiple text inputs",
                    "value": {
                      "object": "list",
                      "model": "private-gpt",
                      "data": [
                        {
                          "index": 0,
                          "object": "embedding",
                          "embedding": [
                            0.234,
                            -0.567,
                            0.123,
                            0.678,
                            -0.234,
                            0.456,
                            -0.789,
                            0.345,
                            -0.123,
                            0.567
                          ]
                        },
                        {
                          "index": 1,
                          "object": "embedding",
                          "embedding": [
                            -0.123,
                            0.456,
                            -0.789,
                            0.234,
                            0.567,
                            -0.345,
                            0.678,
                            -0.234,
                            0.789,
                            -0.456
                          ]
                        },
                        {
                          "index": 2,
                          "object": "embedding",
                          "embedding": [
                            0.567,
                            -0.234,
                            0.789,
                            -0.456,
                            0.123,
                            0.678,
                            -0.345,
                            0.234,
                            -0.567,
                            0.891
                          ]
                        }
                      ]
                    }
                  },
                  "semantic_similarity_example": {
                    "summary": "Embeddings for semantic similarity comparison",
                    "value": {
                      "object": "list",
                      "model": "private-gpt",
                      "data": [
                        {
                          "index": 0,
                          "object": "embedding",
                          "embedding": [
                            0.445,
                            0.223,
                            -0.667,
                            0.112,
                            0.889,
                            -0.334,
                            0.556,
                            -0.778,
                            0.223,
                            0.445
                          ]
                        },
                        {
                          "index": 1,
                          "object": "embedding",
                          "embedding": [
                            0.434,
                            0.234,
                            -0.656,
                            0.123,
                            0.878,
                            -0.345,
                            0.567,
                            -0.789,
                            0.234,
                            0.456
                          ]
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid input format",
            "content": {
              "application/json": {
                "examples": {
                  "missing_input": {
                    "summary": "Missing input field",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "input"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  },
                  "empty_input": {
                    "summary": "Empty input provided",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "input"
                          ],
                          "msg": "Input text cannot be empty",
                          "type": "value_error"
                        }
                      ]
                    }
                  },
                  "invalid_input_type": {
                    "summary": "Invalid input data type",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "input"
                          ],
                          "msg": "Input must be a string or array of strings",
                          "type": "type_error"
                        }
                      ]
                    }
                  },
                  "empty_array": {
                    "summary": "Empty array provided",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "input"
                          ],
                          "msg": "Input array cannot be empty",
                          "type": "value_error"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/artifacts/ingest": {
      "post": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "Ingest Content",
        "description": "Unified endpoint to ingest files, text, URIs, or already processed content",
        "operationId": "ingest_content_v1_artifacts_ingest_post",
        "requestBody": {
          "description": "JSON request body supporting multiple input types",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IngestBody"
              },
              "examples": {
                "file_base64": {
                  "summary": "File content (base64)",
                  "value": {
                    "input": {
                      "type": "file",
                      "value": "JVBERi0xLjQKJaqrrK0KMS..."
                    },
                    "artifact": "quarterly_report",
                    "collection": "financial_docs",
                    "metadata": {
                      "file_name": "Q3_Report.pdf"
                    }
                  }
                },
                "uri": {
                  "summary": "Remote URI",
                  "value": {
                    "input": {
                      "type": "uri",
                      "value": "s3://company-docs/annual-2023.pdf"
                    },
                    "artifact": "annual_report_2023",
                    "collection": "financial_reports",
                    "metadata": {
                      "year": "2023"
                    }
                  }
                },
                "text": {
                  "summary": "Plain text content",
                  "value": {
                    "input": {
                      "type": "text",
                      "value": "Our company was founded in 2020..."
                    },
                    "artifact": "company_profile",
                    "collection": "corporate_docs",
                    "metadata": {
                      "author": "Marketing Team"
                    }
                  }
                },
                "ingested": {
                  "summary": "Already ingested content",
                  "value": {
                    "input": {
                      "type": "ingest",
                      "value": "existing_context_filter_object"
                    },
                    "artifact": "existing_doc",
                    "collection": "processed_docs"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Content successfully ingested and processed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IngestResponse"
                },
                "example": {
                  "object": "list",
                  "model": "private-gpt",
                  "data": [
                    {
                      "object": "ingest.document",
                      "artifact": "quarterly_report",
                      "doc_metadata": {
                        "file_name": "Q3_Report.pdf",
                        "page_number": 1,
                        "total_pages": 10
                      }
                    }
                  ]
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Invalid input format or request parameters",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Invalid input format"
                }
              }
            }
          }
        }
      }
    },
    "/v1/artifacts/ingest/async": {
      "post": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "Ingest Content Asynchronously",
        "description": "Initiate asynchronous ingestion of content from multiple sources",
        "operationId": "ingest_content_async_v1_artifacts_ingest_async_post",
        "requestBody": {
          "description": "JSON request body containing ingestion parameters and callback configuration for asynchronous processing notifications",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IngestAsyncBody"
              },
              "examples": {
                "file_async": {
                  "summary": "Async file ingestion",
                  "value": {
                    "callback": {
                      "amqp": {
                        "exchange": "ingestion_events",
                        "routing_key_done": "ingest.completed",
                        "routing_key_error": "ingest.failed",
                        "routing_key_progress": "ingest.progress"
                      }
                    },
                    "ingest_body": {
                      "input": {
                        "type": "file",
                        "value": "JVBERi0xLjQKJaqrrK0KMS..."
                      },
                      "artifact": "quarterly_report",
                      "collection": "financial_docs",
                      "metadata": {
                        "file_name": "Q3_Report.pdf"
                      }
                    }
                  }
                },
                "uri_async": {
                  "summary": "Async URI ingestion",
                  "value": {
                    "callback": {
                      "amqp": {
                        "exchange": "ingestion_events",
                        "routing_key_done": "ingest.completed",
                        "routing_key_error": "ingest.failed",
                        "routing_key_progress": "ingest.progress"
                      }
                    },
                    "ingest_body": {
                      "input": {
                        "type": "uri",
                        "value": "s3://company-docs/annual-2023.pdf"
                      },
                      "artifact": "annual_report_2023",
                      "collection": "financial_reports",
                      "metadata": {
                        "year": "2023"
                      }
                    }
                  }
                },
                "text_async": {
                  "summary": "Async text ingestion",
                  "value": {
                    "callback": {
                      "amqp": {
                        "exchange": "ingestion_events",
                        "routing_key_done": "ingest.completed",
                        "routing_key_error": "ingest.failed",
                        "routing_key_progress": "ingest.progress"
                      }
                    },
                    "ingest_body": {
                      "input": {
                        "type": "text",
                        "value": "Our company was founded in 2020..."
                      },
                      "artifact": "company_profile",
                      "collection": "corporate_docs",
                      "metadata": {
                        "author": "Marketing Team"
                      }
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successfully initiated ingestion task",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Task"
                },
                "example": {
                  "task_id": "123e4567-e89b-12d3-a456-426614174000"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Invalid input format or request parameters",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Input format is invalid or parameters are missing"
                }
              }
            }
          },
          "404": {
            "description": "Resource not accessible (for URI inputs)",
            "content": {
              "application/json": {
                "example": {
                  "detail": "The URI resource could not be accessed"
                }
              }
            }
          }
        }
      }
    },
    "/v1/artifacts/ingest/async/{task_id}": {
      "get": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "Check Ingestion Task Status",
        "description": "Retrieve the current status and results of an asynchronous ingestion task",
        "operationId": "get_ingest_async_status_v1_artifacts_ingest_async__task_id__get",
        "parameters": [
          {
            "name": "task_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Unique identifier of the ingestion task to check status for",
              "examples": [
                "123e4567-e89b-12d3-a456-426614174000"
              ],
              "title": "Task Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved task status and results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskStatus_IngestResponse_"
                },
                "examples": {
                  "completed_task": {
                    "summary": "Completed ingestion task with results",
                    "value": {
                      "task_id": "123e4567-e89b-12d3-a456-426614174000",
                      "task_status": "SUCCESS",
                      "task_result": {
                        "object": "list",
                        "model": "private-gpt",
                        "data": [
                          {
                            "object": "ingest.document",
                            "artifact": "annual_report",
                            "doc_metadata": {
                              "file_name": "report.pdf",
                              "page_count": 45,
                              "department": "finance"
                            }
                          }
                        ]
                      }
                    }
                  },
                  "pending_task": {
                    "summary": "Task still in progress",
                    "value": {
                      "task_id": "456e7890-e89b-12d3-a456-426614174001",
                      "task_status": "PENDING"
                    }
                  },
                  "failed_task": {
                    "summary": "Failed ingestion task with error",
                    "value": {
                      "task_id": "789e0123-e89b-12d3-a456-426614174002",
                      "task_status": "FAILURE",
                      "task_result": "File format not supported or URI inaccessible"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Task not found or expired",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task with specified ID not found"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/artifacts/list": {
      "get": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "List Ingested Documents",
        "description": "Retrieve a list of all documents ingested into a specific collection",
        "operationId": "list_ingested_v1_artifacts_list_get",
        "parameters": [
          {
            "name": "collection",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the collection to list documents from",
              "examples": [
                "pgpt_collection",
                "financial_reports",
                "hr_documents"
              ],
              "default": "pgpt_collection",
              "title": "Collection"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved document list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IngestResponse"
                },
                "example": {
                  "object": "list",
                  "model": "private-gpt",
                  "data": [
                    {
                      "object": "ingest.document",
                      "artifact": "annual_report",
                      "doc_metadata": {
                        "file_name": "2023_Annual.pdf",
                        "department": "finance",
                        "date": "2023-12-31"
                      }
                    },
                    {
                      "object": "ingest.document",
                      "artifact": "policy_manual",
                      "doc_metadata": {
                        "file_name": "employee_policy.docx",
                        "department": "hr",
                        "version": "2.1"
                      }
                    }
                  ]
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Invalid collection name",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Collection name is invalid"
                }
              }
            }
          }
        }
      }
    },
    "/v1/artifacts/delete": {
      "post": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "Delete Ingested Document",
        "description": "Remove a specific document and all its associated data from the system",
        "operationId": "delete_ingested_v1_artifacts_delete_post",
        "requestBody": {
          "description": "JSON request body specifying the collection and artifact to be deleted from the system",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteIngestedDocumentBody"
              },
              "example": {
                "collection": "financial_reports",
                "artifact": "q2_2023_report"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Document successfully deleted"
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/artifacts/delete/async": {
      "post": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "Delete Document Asynchronously",
        "description": "Initiates asynchronous deletion of a document and all associated data.\n\nThis endpoint queues a deletion task for background processing, making it\nsuitable for large documents or when non-blocking operation is required.\nThe task can be monitored using the returned task ID.\n\nIf an ingestion task is currently running for the same document, it will\nbe automatically revoked before initiating the deletion.",
        "operationId": "delete_ingested_async_v1_artifacts_delete_async_post",
        "requestBody": {
          "description": "JSON request body containing deletion parameters and optional callback configuration for asynchronous processing notifications",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteIngestedDocumentAsyncBody"
              },
              "example": {
                "callback": {
                  "amqp": {
                    "exchange": "deletion_events",
                    "routing_key_done": "delete.completed",
                    "routing_key_error": "delete.failed",
                    "routing_key_progress": "delete.progress"
                  }
                },
                "delete_body": {
                  "collection": "financial_reports",
                  "artifact": "obsolete_report_2022"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successfully initiated deletion task",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Task"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Invalid request parameters"
          }
        }
      }
    },
    "/v1/artifacts/delete/async/{task_id}": {
      "get": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "Check Deletion Task Status",
        "description": "Retrieve the current status of an asynchronous deletion task",
        "operationId": "get_delete_async_status_v1_artifacts_delete_async__task_id__get",
        "parameters": [
          {
            "name": "task_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Unique identifier of the deletion task to check status for",
              "examples": [
                "123e4567-e89b-12d3-a456-426614174000"
              ],
              "title": "Task Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved task status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskStatus_NoneType_"
                },
                "examples": {
                  "completed_deletion": {
                    "summary": "Completed deletion task",
                    "value": {
                      "task_id": "123e4567-e89b-12d3-a456-426614174000",
                      "task_status": "SUCCESS"
                    }
                  },
                  "pending_deletion": {
                    "summary": "Deletion task in progress",
                    "value": {
                      "task_id": "456e7890-e89b-12d3-a456-426614174001",
                      "task_status": "PENDING"
                    }
                  },
                  "failed_deletion": {
                    "summary": "Failed deletion task",
                    "value": {
                      "task_id": "789e0123-e89b-12d3-a456-426614174002",
                      "task_status": "FAILURE",
                      "task_result": "Document not found in collection"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Task not found or expired",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task with specified ID not found"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/artifacts/content": {
      "post": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "Retrieve Full Document Content",
        "description": "Retrieve the full content of filtered documents.\n\nThis endpoint provides access to complete document content rather than\nsemantic chunks. Use this when you need the entire context of documents\nrather than relevant excerpts.\n\nKey Features:\n* Full Content: Get complete documents rather than chunks\n* Filtered Retrieval: Select specific documents using metadata filters\n* Bulk Retrieval: Get multiple documents in one request\n* Original Formatting: Returns documents in their original text format\n\nNotes:\n* This endpoint returns unprocessed document content\n* Use specific filtering to avoid large response payloads\n* Content maintains original document structure and formatting",
        "operationId": "content_retrieval_v1_artifacts_content_post",
        "requestBody": {
          "description": "Request body for retrieving full document content.\n\nContains context filtering options to select specific documents by collection, artifacts, and metadata criteria. Unlike chunk retrieval, this returns complete document content rather than excerpts.\n\nThe request body defines filtering criteria for bulk document content retrieval from the ingested knowledge base.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContentBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful content retrieval",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResponse"
                },
                "examples": {
                  "full_documents": {
                    "summary": "Complete document content retrieval",
                    "value": {
                      "data": [
                        {
                          "artifact_id": "annual_report_2023",
                          "content": "ANNUAL REPORT 2023\n\nExecutive Summary\n\nFiscal year 2023 marked a transformative period for our organization with record-breaking performance across all key metrics...\n\n[Full document content continues...]"
                        },
                        {
                          "artifact_id": "quarterly_summary_q4",
                          "content": "Q4 QUARTERLY SUMMARY\n\nQuarter Overview\n\nThe fourth quarter concluded our strongest year on record, with revenue growth of 34% year-over-year...\n\n[Full document content continues...]"
                        }
                      ]
                    }
                  },
                  "filtered_documents": {
                    "summary": "Documents filtered by metadata",
                    "value": {
                      "data": [
                        {
                          "artifact_id": "finance_report_dec",
                          "content": "DECEMBER FINANCIAL REPORT\n\nRevenue Analysis\n\nDecember revenue reached $850K, representing a 12% increase from November. Key drivers included enterprise sales and subscription renewals...\n\n[Full document content continues...]"
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "missing_context_filter": {
                    "summary": "Missing context filter",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "context_filter"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  },
                  "invalid_collection": {
                    "summary": "Invalid collection reference",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "context_filter",
                            "collection"
                          ],
                          "msg": "Collection 'nonexistent' not found",
                          "type": "value_error"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/artifacts/chunked-content": {
      "post": {
        "tags": [
          "Artifacts",
          "Artifacts"
        ],
        "summary": "Retrieve Full Document Content in Chunks",
        "description": "Retrieve full document content split into chat-optimized chunks.\n\nThis endpoint provides access to complete document content split into\nmanageable chunks suitable for chat interfaces. Unlike semantic chunk\nretrieval, this returns complete documents divided sequentially.\n\nKey Features:\n* Chat-Optimized Chunking: Documents split into conversational pieces\n* Token-Aware Splitting: Respects token limits for chat context management\n* Sequential Chunks: Maintains document order and narrative flow\n* Filtered Retrieval: Select specific documents using metadata filters\n* Token Limiting: Optional max_tokens parameter to control response size\n\nChunking Process:\n1. Retrieve filtered documents based on context criteria\n2. Split documents into chat-appropriate segments or max tokens\n3. Return structured chunks with metadata\n\nNotes:\n* Chunks maintain document structure and logical flow\n* Token limiting prevents context window overflow\n* Use `/artifacts/search` endpoint for semantic search instead",
        "operationId": "chunked_content_retrieval_v1_artifacts_chunked_content_post",
        "requestBody": {
          "description": "Request body for retrieving chunked document content.\n\nContains context filtering options to select specific documents by collection, artifacts, and metadata criteria, plus optional token limiting for chat optimization.\n\nThe request body defines filtering criteria and chunking parameters for retrieving documents split into chat-ready content blocks with citations.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContentBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful chunked content retrieval",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunkedContentResponse"
                },
                "examples": {
                  "chunked_documents": {
                    "summary": "Complete documents split into chat chunks",
                    "value": {
                      "data": [
                        {
                          "artifact_id": "annual_report_2023",
                          "content": [
                            {
                              "type": "text",
                              "text": "ANNUAL REPORT 2023\n\nExecutive Summary\n\nFiscal year 2023 marked a transformative period for our organization with record-breaking performance across all key metrics."
                            },
                            {
                              "type": "text",
                              "text": "Revenue Analysis\n\nTotal revenue reached $12.4M, representing a 34% increase year-over-year. Growth was driven primarily by enterprise customer acquisition and subscription renewals."
                            }
                          ]
                        },
                        {
                          "artifact_id": "quarterly_summary_q4",
                          "content": [
                            {
                              "type": "text",
                              "text": "Q4 QUARTERLY SUMMARY\n\nQuarter Overview\n\nThe fourth quarter concluded our strongest year on record, with significant achievements in customer satisfaction and operational efficiency."
                            }
                          ]
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "missing_context_filter": {
                    "summary": "Missing context filter",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "context_filter"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  },
                  "invalid_max_tokens": {
                    "summary": "Invalid max tokens parameter",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "max_tokens"
                          ],
                          "msg": "ensure this value is greater than or equal to 1",
                          "type": "value_error.number.not_ge"
                        }
                      ]
                    }
                  },
                  "invalid_collection": {
                    "summary": "Invalid collection reference",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "context_filter",
                            "collection"
                          ],
                          "msg": "Collection 'nonexistent' not found",
                          "type": "value_error"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/primitives/search": {
      "post": {
        "tags": [
          "Primitives",
          "Primitives"
        ],
        "summary": "Retrieve Chunks using Semantic, Keyword, or Hybrid Search",
        "description": "Perform document chunk search using semantic, keyword, or hybrid strategies.\n\nThis endpoint provides flexible search capabilities across ingested documents\nwith support for different search strategies based on use case requirements.\n\nSearch Types:\n* **Semantic Search**: Uses vector embeddings to find chunks with similar meaning\n  to the provided text query, regardless of exact keyword matches\n* **Keyword Search**: Finds chunks containing specific keywords with exact or\n  fuzzy matching capabilities (implementation pending)\n* **Hybrid Search**: Combines semantic similarity with keyword matching for\n  comprehensive results (implementation pending)\n\nKey Features:\n* **Score-based Ranking**: Results include similarity/relevance scores\n* **Context Filtering**: Narrow search to specific collections,\nartifacts, or metadata\n* **Adjacent Context**: Optionally retrieve surrounding chunks for richer context\n* **Configurable Limits**: Control result count (1-100 chunks)\n* **Flexible Matching**: Choose optimal strategy based on query type\n\nSearch Process:\n1. Parse request to determine search strategy and parameters\n2. Apply context filters to narrow search scope\n3. Execute search using appropriate algorithm (semantic/keyword/hybrid)\n4. Rank results by relevance score\n5. Optionally expand results with adjacent chunks for context\n\nCurrent Implementation Status:\n*  Semantic Search: Fully implemented and production-ready\n*  Keyword Search: Planned feature, returns 400 if requested\n*  Hybrid Search: Planned feature, returns 400 if requested\n\nNotes:\n* Higher scores indicate better matches\n* Expansion increases response time but provides richer context\n* Use `/artifacts/list` to discover available collections and metadata\n* Semantic search works best for conceptual queries\n* Keyword search (when available) will excel at exact term matching",
        "operationId": "search_v1_primitives_search_post",
        "requestBody": {
          "description": "Request body for searching document chunks using different strategies.\n\nSupports three search types:\n- **semantic_search**: Find chunks based on semantic similarity to the text query\n- **keywords_search**: Find chunks containing specific keywords (coming soon)\n- **hybrid_search**: Combine semantic and keyword matching (coming soon)\n\nThe request body defines search criteria, context filtering options, result limits, and expansion settings for retrieving relevant document chunks.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchBody",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/SemanticSearch"
                  },
                  {
                    "$ref": "#/components/schemas/KeywordSearch"
                  },
                  {
                    "$ref": "#/components/schemas/HybridSearch"
                  }
                ],
                "title": "Body",
                "discriminator": {
                  "propertyName": "type",
                  "mapping": {
                    "semantic_search": "#/components/schemas/SemanticSearch",
                    "keywords_search": "#/components/schemas/KeywordSearch",
                    "hybrid_search": "#/components/schemas/HybridSearch"
                  }
                }
              },
              "examples": {
                "semantic_search": {
                  "summary": "Semantic Search Example",
                  "value": {
                    "type": "semantic_search",
                    "text": "Q3 2023 sales performance",
                    "context_filter": {
                      "collections": [
                        "reports"
                      ]
                    },
                    "limit": 10,
                    "expand": true
                  }
                },
                "keyword_search": {
                  "summary": "Keyword Search Example (Coming Soon)",
                  "value": {
                    "type": "keywords_search",
                    "keywords": [
                      "sales",
                      "Q3",
                      "2023"
                    ],
                    "context_filter": {
                      "artifacts": [
                        "q3_report"
                      ]
                    },
                    "limit": 5
                  }
                },
                "hybrid_search": {
                  "summary": "Hybrid Search Example (Coming Soon)",
                  "value": {
                    "type": "hybrid_search",
                    "text": "quarterly sales analysis",
                    "keywords": [
                      "revenue",
                      "growth",
                      "metrics"
                    ],
                    "context_filter": {
                      "collections": [
                        "financial"
                      ]
                    },
                    "limit": 15,
                    "expand": false
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful chunk retrieval",
            "content": {
              "application/json": {
                "schema": {},
                "examples": {
                  "semantic_search_results": {
                    "summary": "Semantic search with chunks",
                    "value": {
                      "object": "list",
                      "model": "private-gpt",
                      "data": [
                        {
                          "object": "context.chunk",
                          "score": 0.89,
                          "document": {
                            "object": "ingest.document",
                            "artifact": "q3_report",
                            "doc_metadata": {
                              "title": "Q3 2023 Report",
                              "file_name": "Q3_Sales.pdf"
                            }
                          },
                          "text": "Q3 sales increased by 25% compared to Q2, driven primarily by new customer acquisitions in the enterprise segment.",
                          "previous_texts": [
                            "Q2 comparison shows steady growth trends."
                          ],
                          "next_texts": [
                            "Regional breakdown indicates strongest performance in North America."
                          ]
                        },
                        {
                          "object": "context.chunk",
                          "score": 0.76,
                          "document": {
                            "object": "ingest.document",
                            "artifact": "q3_report",
                            "doc_metadata": {
                              "title": "Q3 2023 Report",
                              "page_number": 5
                            }
                          },
                          "text": "Sales performance metrics exceeded targets across all key verticals during the third quarter."
                        }
                      ]
                    }
                  },
                  "keyword_search_results": {
                    "summary": "Keyword-based search results",
                    "value": {
                      "object": "list",
                      "model": "private-gpt",
                      "data": [
                        {
                          "object": "context.chunk",
                          "score": 0.95,
                          "document": {
                            "object": "ingest.document",
                            "artifact": "financial_docs",
                            "doc_metadata": {
                              "department": "finance",
                              "quarter": "Q3"
                            }
                          },
                          "text": "Q3 2023 sales figures show significant growth in revenue streams."
                        }
                      ]
                    }
                  },
                  "hybrid_search_results": {
                    "summary": "Combined semantic and keyword search",
                    "value": {
                      "object": "list",
                      "model": "private-gpt",
                      "data": [
                        {
                          "object": "context.chunk",
                          "score": 0.91,
                          "document": {
                            "object": "ingest.document",
                            "artifact": "annual_report",
                            "doc_metadata": {
                              "year": "2023"
                            }
                          },
                          "text": "Annual sales performance demonstrates consistent growth with Q3 being the strongest quarter.",
                          "previous_texts": [
                            "Market analysis indicates favorable conditions."
                          ],
                          "next_texts": [
                            "Strategic initiatives continue to drive results."
                          ]
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "invalid_search_type": {
                    "summary": "Unsupported search type",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "type"
                          ],
                          "msg": "Invalid search type. Supported types: semantic_search, keywords_search, hybrid_search",
                          "type": "value_error"
                        }
                      ]
                    }
                  },
                  "invalid_limit": {
                    "summary": "Limit parameter out of range",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "limit"
                          ],
                          "msg": "ensure this value is less than or equal to 100",
                          "type": "value_error.number.not_le"
                        }
                      ]
                    }
                  },
                  "empty_text_query": {
                    "summary": "Missing text query for semantic or hybrid search",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "text"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  },
                  "empty_keywords": {
                    "summary": "Missing keywords for keyword or hybrid search",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "keywords"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  },
                  "invalid_context_filter": {
                    "summary": "Invalid context filter format",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "context_filter"
                          ],
                          "msg": "Invalid context filter configuration",
                          "type": "value_error"
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "501": {
            "description": "Not Implemented - Search type not yet supported",
            "content": {
              "application/json": {
                "examples": {
                  "feature_not_implemented": {
                    "summary": "Keyword or hybrid search not yet implemented",
                    "value": {
                      "detail": "Search type 'keywords_search' or 'hybrid_search' is not yet implemented. Currently only 'semantic_search' is supported."
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/tools/semantic-search": {
      "post": {
        "tags": [
          "Tools"
        ],
        "summary": "Semantic Search",
        "description": "Run a semantic search using natural language and contextual filters. Supports citation formatting.",
        "operationId": "semantic_search_v1_tools_semantic_search_post",
        "requestBody": {
          "description": "Request body for semantic search. Includes the query, optional filters, and response formatting preferences.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SemanticSearchBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Semantic search completed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolResponse"
                },
                "examples": {
                  "rich_semantic_response": {
                    "summary": "Search result with sources",
                    "value": {
                      "content": [
                        {
                          "type": "source",
                          "sources": [
                            {
                              "object": "context.chunk",
                              "id": "d3ab07fe-b7ab-4fda-8524-1cb41b01200a",
                              "score": 0.83,
                              "document": {
                                "object": "ingest.document",
                                "artifact": "0196ee69-666a-7bcd-800b-b01fa9b2f24c",
                                "doc_metadata": {
                                  "file_name": "dense_x_retrieval.pdf"
                                }
                              },
                              "text": "Wenhao Yu et al. 2023. Chain-ofnote: Enhancing robustness in retrieval-augmented LMs.",
                              "content_type": "text/markdown",
                              "metadata": {
                                "page": 13,
                                "shorter_id": "GONG"
                              },
                              "previous_texts": [],
                              "next_texts": []
                            }
                          ]
                        },
                        {
                          "type": "text",
                          "text": "**Context Information**:\nCitation identifier [GONG]\n---\nContent:\nWenhao Yu, Hongming Zhang... Chain-ofnote: Enhancing robustness in retrieval-augmented language models."
                        }
                      ],
                      "is_error": false
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "missing_query": {
                    "summary": "Missing query field",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "query"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  },
                  "invalid_format": {
                    "summary": "Invalid format value",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "format"
                          ],
                          "msg": "value is not a valid enumeration member; permitted: 'default', 'citations'",
                          "type": "type_error.enum"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/tools/tabular-data-analysis": {
      "post": {
        "tags": [
          "Tools"
        ],
        "summary": "Tabular Data Analysis",
        "description": "Analyze structured tabular data using a natural language query.",
        "operationId": "tabular_data_analysis_v1_tools_tabular_data_analysis_post",
        "requestBody": {
          "description": "Request body for analyzing tabular data using a natural language query. Includes filters to scope the documents containing structured data.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TabularDataAnalysisBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Tabular analysis completed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolResponse"
                },
                "examples": {
                  "successful_analysis": {
                    "summary": "Simple text result from tabular analysis",
                    "value": {
                      "content": [
                        {
                          "type": "text",
                          "text": "Average revenue across departments: Sales - $1.2M, Marketing - $850K..."
                        }
                      ],
                      "is_error": false
                    }
                  },
                  "text_and_image_output": {
                    "summary": "Text + image result from tabular analysis",
                    "value": {
                      "content": [
                        {
                          "type": "text",
                          "text": "The bar chart shows that Q4 revenue was highest in the Sales department."
                        },
                        {
                          "type": "image",
                          "data": "iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==",
                          "mime_type": "image/png"
                        }
                      ],
                      "is_error": false
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "missing_query": {
                    "summary": "Missing analysis query",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "query"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/tools/database-query": {
      "post": {
        "tags": [
          "Tools"
        ],
        "summary": "Database Query",
        "description": "Run a natural language query against connected SQL databases.",
        "operationId": "database_query_v1_tools_database_query_post",
        "requestBody": {
          "description": "Request body for querying connected SQL databases using natural language. Requires at least one SQL database artifact in the tool context.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DatabaseQueryBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Database query completed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolResponse"
                },
                "examples": {
                  "successful_query": {
                    "summary": "Simple text result from database query",
                    "value": {
                      "content": [
                        {
                          "type": "text",
                          "text": "The total revenue for Q4 was $3.5M, with the highest contributions from the Sales department."
                        }
                      ],
                      "is_error": false
                    }
                  },
                  "query_with_table_result": {
                    "summary": "Text + table result from database query",
                    "value": {
                      "content": [
                        {
                          "type": "text",
                          "text": "Here is the breakdown of revenue by department for Q4:"
                        },
                        {
                          "type": "table",
                          "data": {
                            "columns": [
                              "Department",
                              "Revenue"
                            ],
                            "rows": [
                              [
                                "Sales",
                                "$1.2M"
                              ],
                              [
                                "Marketing",
                                "$850K"
                              ],
                              [
                                "Engineering",
                                "$1.45M"
                              ]
                            ]
                          }
                        }
                      ],
                      "is_error": false
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "missing_query": {
                    "summary": "Missing query field",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "query"
                          ],
                          "msg": "field required",
                          "type": "value_error.missing"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/tools/web-fetch": {
      "post": {
        "tags": [
          "Tools"
        ],
        "summary": "Web Fetch",
        "description": "Fetch and extract content from a specified web URL.",
        "operationId": "web_fetch_v1_tools_web_fetch_post",
        "requestBody": {
          "description": "Request body for fetching web content. The last user message must contain a valid URL.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebFetchBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Web content fetched successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolResponse"
                },
                "examples": {
                  "successful_fetch": {
                    "summary": "Fetched text content from a web page",
                    "value": {
                      "content": [
                        {
                          "type": "text",
                          "text": "This is the main content extracted from the web page..."
                        }
                      ],
                      "is_error": false
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "missing_url": {
                    "summary": "Missing URL in the last user message",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "context_filter"
                          ],
                          "msg": "No URL found in the last user message.",
                          "type": "value_error"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/tools/web-search": {
      "post": {
        "tags": [
          "Tools"
        ],
        "summary": "Web Search",
        "description": "Search the web for information related to a natural language query.",
        "operationId": "web_search_v1_tools_web_search_post",
        "requestBody": {
          "description": "Request body for fetching web content. The last user message must contain a valid URL.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebFetchBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Web search completed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolResponse"
                },
                "examples": {
                  "successful_fetch": {
                    "summary": "Fetched text content from a web page",
                    "value": {
                      "content": [
                        {
                          "type": "text",
                          "text": "This is the main content extracted from the web page..."
                        }
                      ],
                      "is_error": false
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "422": {
            "description": "Validation Error - Invalid request parameters",
            "content": {
              "application/json": {
                "examples": {
                  "missing_url": {
                    "summary": "Missing URL in the last user message",
                    "value": {
                      "detail": [
                        {
                          "loc": [
                            "body",
                            "context_filter"
                          ],
                          "msg": "No URL found in the last user message.",
                          "type": "value_error"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AMQP": {
        "properties": {
          "exchange": {
            "type": "string",
            "title": "Exchange",
            "description": "AMQP exchange name where task notifications will be published",
            "examples": [
              "ingest"
            ]
          },
          "routing_key_done": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Routing Key Done",
            "description": "Routing key used when publishing task completion notifications",
            "examples": [
              "ingest.done"
            ]
          },
          "routing_key_progress": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Routing Key Progress",
            "description": "Routing key used when publishing task progress update notifications",
            "examples": [
              "ingest.progress"
            ]
          },
          "routing_key_error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Routing Key Error",
            "description": "Routing key used when publishing task error notifications",
            "examples": [
              "ingest.error"
            ]
          }
        },
        "type": "object",
        "required": [
          "exchange"
        ],
        "title": "AMQP",
        "description": "AMQP configuration for message queue notifications."
      },
      "AudioBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "audio",
            "title": "Type",
            "description": "Content block type identifier for audio content",
            "default": "audio"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "data": {
            "type": "string",
            "title": "Data",
            "description": "Base64-encoded audio data"
          },
          "mime_type": {
            "type": "string",
            "title": "Mime Type",
            "description": "MIME type of the audio (e.g., 'audio/mpeg', 'audio/wav')"
          }
        },
        "type": "object",
        "required": [
          "data",
          "mime_type"
        ],
        "title": "AudioBlock",
        "description": "Audio content block containing audio media."
      },
      "BinaryBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "binary",
            "title": "Type",
            "description": "Content block type identifier for binary content",
            "default": "binary"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "filename": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filename",
            "description": "Optional filename for the binary data"
          },
          "data": {
            "type": "string",
            "title": "Data",
            "description": "Base64-encoded binary data"
          },
          "mime_type": {
            "type": "string",
            "title": "Mime Type",
            "description": "MIME type of the binary data (e.g., 'application/pdf', 'application/zip')"
          }
        },
        "type": "object",
        "required": [
          "data",
          "mime_type"
        ],
        "title": "BinaryBlock",
        "description": "Binary content block containing arbitrary binary data."
      },
      "Callback": {
        "properties": {
          "amqp": {
            "$ref": "#/components/schemas/AMQP",
            "description": "AMQP (Advanced Message Queuing Protocol) configuration for task status notifications",
            "examples": [
              {
                "exchange": "ingest",
                "routing_key_done": "ingest.done",
                "routing_key_error": "ingest.error"
              }
            ]
          },
          "properties": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Properties",
            "description": "Additional properties and metadata to include with callback notifications",
            "examples": [
              {
                "key": "value"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "amqp"
        ],
        "title": "Callback",
        "description": "Callback configuration for asynchronous task notifications."
      },
      "ChatBody": {
        "properties": {
          "model": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Model",
            "description": "Model to use for the chat completion. If not provided, the default model will be used."
          },
          "stream": {
            "type": "boolean",
            "title": "Stream",
            "description": "Whether to stream the response back to the client.",
            "default": false
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/MessageInput"
            },
            "type": "array",
            "title": "Messages",
            "description": "Array of messages composing the chat conversation.\n        Each message should have a 'role' (user, or assistant) and 'content'."
          },
          "tools": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ToolSpec"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tools",
            "description": "List of tools to use for the response."
          },
          "tool_choice": {
            "$ref": "#/components/schemas/ToolChoice",
            "description": "Define how the model should choose tools for the response. ",
            "default": {
              "type": "auto",
              "disable_parallel_tool_use": false,
              "validation_mode": "lazy"
            }
          },
          "tool_context": {
            "anyOf": [
              {
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/FileArtifact"
                    },
                    {
                      "$ref": "#/components/schemas/UriArtifact"
                    },
                    {
                      "$ref": "#/components/schemas/TextArtifact"
                    },
                    {
                      "$ref": "#/components/schemas/IngestedArtifact"
                    },
                    {
                      "$ref": "#/components/schemas/SqlDatabaseArtifact"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "file": "#/components/schemas/FileArtifact",
                      "ingested_artifact": "#/components/schemas/IngestedArtifact",
                      "sql_database": "#/components/schemas/SqlDatabaseArtifact",
                      "text": "#/components/schemas/TextArtifact",
                      "uri": "#/components/schemas/UriArtifact"
                    }
                  }
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tool Context",
            "description": "Context to provide to the tools, such as documents,\n        databases connection strings, or data relevant to tool usage."
          },
          "mcp_servers": {
            "items": {
              "$ref": "#/components/schemas/McpServerConfig"
            },
            "type": "array",
            "title": "Mcp Servers",
            "description": "List of MCP servers to use for tool retrieval. Each server can have its own configuration."
          },
          "response_format": {
            "$ref": "#/components/schemas/ResponseFormat",
            "description": "Format of the response. Can be text, json_schema, or tool call.",
            "default": {
              "type": "text"
            }
          },
          "system": {
            "$ref": "#/components/schemas/System",
            "description": "System message configuration, including default prompt and citations.",
            "default": {
              "use_default_prompt": false,
              "citations": {
                "enabled": false
              },
              "extensions": []
            }
          },
          "thinking": {
            "$ref": "#/components/schemas/Thinking",
            "description": "Thinking configuration, enabling reasoning capabilities for the model.",
            "default": {
              "enabled": false
            }
          },
          "priority": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Priority",
            "description": "Priority of the request, used for prioritizing responses."
          },
          "seed": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Seed",
            "description": "Random seed for reproducibility."
          },
          "min_p": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Min P",
            "description": "Minimum probability threshold for token selection. Tokens with probability below this value are filtered out."
          },
          "top_p": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Top P",
            "description": "Nucleus sampling parameter. Only tokens with cumulative probability up to this value are considered."
          },
          "temperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Temperature",
            "description": "Controls randomness in generation. Higher values make output more random, lower values more deterministic."
          },
          "top_k": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Top K",
            "description": "Limits token selection to the top K most likely tokens at each step."
          },
          "repetition_penalty": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Repetition Penalty",
            "description": "Penalty applied to tokens that have already appeared in the sequence to reduce repetition."
          },
          "presence_penalty": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Presence Penalty",
            "description": "Penalty applied based on whether a token has appeared in the text, encouraging topic diversity."
          },
          "frequency_penalty": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Frequency Penalty",
            "description": "Penalty applied based on how frequently a token appears in the text, reducing repetitive content."
          },
          "max_tokens": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Tokens",
            "description": "Maximum number of tokens to generate in the response."
          },
          "correlation_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correlation Id",
            "description": "Correlation ID for tracking the request across systems."
          }
        },
        "type": "object",
        "required": [
          "messages"
        ],
        "title": "ChatBody",
        "description": "Chat request body model for handling chat interactions.",
        "examples": [
          {
            "max_tokens": 1000,
            "messages": [
              {
                "content": "How do you fry an egg? Choose the best method.",
                "role": "user"
              }
            ],
            "response_format": {
              "type": "text"
            },
            "stream": false,
            "system": {
              "citations": {
                "enabled": true
              },
              "text": "You are a helpful cooking assistant. Provide clear, step-by-step instructions.",
              "use_default_prompt": true
            },
            "temperature": 0.7,
            "thinking": {
              "enabled": false
            },
            "tool_choice": {
              "disable_parallel_tool_use": false,
              "type": "auto"
            },
            "tools": [
              {
                "description": "A tool to fry eggs with precise temperature control",
                "input_schema": {
                  "properties": {
                    "temperature": {
                      "description": "Temperature in degrees Celsius",
                      "type": "number"
                    },
                    "time": {
                      "description": "Time in minutes to fry the egg",
                      "type": "number"
                    }
                  },
                  "required": [
                    "temperature",
                    "time"
                  ],
                  "type": "object"
                },
                "name": "egg_fryer"
              }
            ]
          },
          {
            "mcp_servers": [
              {
                "tool_configuration": {
                  "enabled": true,
                  "enabled_tools": [
                    "weather_get",
                    "weather_forecast"
                  ]
                },
                "url": "http://localhost:8080/mcp"
              }
            ],
            "messages": [
              {
                "content": "What's the weather like today?",
                "role": "user"
              }
            ],
            "stream": true,
            "system": {
              "citations": {
                "enabled": false
              },
              "text": "You are a weather assistant. Provide current and accurate weather information.",
              "use_default_prompt": false
            },
            "temperature": 0.3,
            "thinking": {
              "enabled": true
            },
            "tool_choice": {
              "type": "auto"
            },
            "top_p": 0.9
          },
          {
            "messages": [
              {
                "content": "Generate a JSON response with user profile data",
                "role": "user"
              }
            ],
            "response_format": {
              "json_schema": {
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "age": {
                    "type": "number"
                  }
                },
                "type": "object"
              },
              "type": "json_schema"
            },
            "seed": 42,
            "stream": false,
            "system": {
              "citations": {
                "enabled": false
              },
              "text": "You are a data generator. Always respond with valid JSON.",
              "use_default_prompt": false
            },
            "thinking": {
              "enabled": false
            },
            "tool_choice": {
              "type": "none"
            }
          },
          {
            "messages": [
              {
                "content": "How many users are there in the users table?",
                "role": "user"
              }
            ],
            "tool_context": [
              {
                "connection_string": "postgres://postgres:postgres@localhost:5432/main",
                "schemas": [
                  "public"
                ],
                "type": "sql_database"
              }
            ],
            "tools": [
              {
                "name": "database_query",
                "type": "database_query_v1"
              }
            ]
          }
        ]
      },
      "ChatCancellationResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Confirmation message for successful stream cancellation"
          },
          "message_id": {
            "type": "string",
            "title": "Message Id",
            "description": "Unique identifier of the cancelled stream"
          }
        },
        "type": "object",
        "required": [
          "message",
          "message_id"
        ],
        "title": "ChatCancellationResponse",
        "description": "Response model for cancelled asynchronous chat streams"
      },
      "ChatResponse": {
        "properties": {
          "message_id": {
            "type": "string",
            "title": "Message Id",
            "description": "Unique identifier for the initiated stream"
          },
          "status": {
            "$ref": "#/components/schemas/StreamStatus",
            "description": "Initial status of the stream (typically 'pending')"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Confirmation message for successful stream initiation",
            "default": "Request initiated successfully"
          }
        },
        "type": "object",
        "required": [
          "message_id",
          "status"
        ],
        "title": "ChatResponse",
        "description": "Response model for initiated asynchronous chat completion streams"
      },
      "ChatValidationResult": {
        "properties": {
          "valid": {
            "type": "boolean",
            "title": "Valid",
            "description": "Is the request valid",
            "default": false
          },
          "errors": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Errors",
            "description": "List of validation errors if any"
          }
        },
        "type": "object",
        "title": "ChatValidationResult",
        "description": "Result of chat request validation."
      },
      "Chunk": {
        "properties": {
          "object": {
            "type": "string",
            "const": "context.chunk",
            "title": "Object",
            "description": "Object type identifier, always 'context.chunk' for chunk responses"
          },
          "id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Id",
            "description": "Unique identifier for the chunk within the document",
            "examples": [
              "chunk_123e4567-e89b-12d3-a456-426614174000",
              "doc_page_1_chunk_3"
            ]
          },
          "score": {
            "type": "number",
            "maximum": 1.01,
            "minimum": -0.01,
            "title": "Score",
            "description": "Relevance score indicating how well this chunk matches the query (0.0 to 1.0, higher is better)",
            "examples": [
              0.023,
              0.856,
              0.342
            ]
          },
          "document": {
            "$ref": "#/components/schemas/IngestedDoc",
            "description": "Reference to the parent document containing metadata and ingestion information"
          },
          "text": {
            "type": "string",
            "title": "Text",
            "description": "The actual text content of the chunk extracted from the document",
            "examples": [
              "Outbound sales increased 20%, driven by new leads.",
              "The quarterly financial report shows significant growth in the technology sector.",
              "Avatar is set in an Asian and Arctic-inspired world where some people can manipulate elements."
            ]
          },
          "content_type": {
            "type": "string",
            "title": "Content Type",
            "description": "MIME type indicating the format of the chunk content",
            "default": "text/plain",
            "examples": [
              "text/plain",
              "text/html",
              "text/markdown",
              "application/json"
            ]
          },
          "previous_texts": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Previous Texts",
            "description": "List of text chunks that appear before this chunk in the document, providing preceding context",
            "examples": [
              [
                "SALES REPORT 2023",
                "Inbound didn't show major changes."
              ],
              [
                "Chapter 1: Introduction",
                "Our company mission is to innovate."
              ],
              null
            ]
          },
          "next_texts": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Texts",
            "description": "List of text chunks that appear after this chunk in the document, providing following context",
            "examples": [
              [
                "New leads came from Google Ads campaign.",
                "The campaign was run by the Marketing Department"
              ],
              [
                "The next quarter will focus on customer retention.",
                "Budget allocation has been approved."
              ],
              null
            ]
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional metadata about the chunk including positioning information and document properties",
            "examples": [
              {
                "abs_idx": 5,
                "author": "John Doe",
                "date": "2023-01-01",
                "rel_idx": 2,
                "title": "Sales Report 2023"
              },
              {
                "abs_idx": 12,
                "file_name": "quarterly_report.pdf",
                "page_number": 3,
                "rel_idx": 0,
                "section": "Financial Overview"
              },
              null
            ]
          }
        },
        "type": "object",
        "required": [
          "object",
          "score",
          "document",
          "text"
        ],
        "title": "Chunk",
        "description": "Represents a chunk of text content from an ingested document.",
        "examples": [
          {
            "content_type": "text/plain",
            "document": {
              "artifact": "quarterly_report_q3",
              "doc_metadata": {
                "department": "finance",
                "file_name": "Q3_Financial_Report.pdf",
                "page_number": 5
              },
              "object": "ingest.document"
            },
            "id": "chunk_123e4567-e89b-12d3-a456-426614174000",
            "metadata": {
              "abs_idx": 8,
              "author": "Finance Team",
              "date": "2023-10-15",
              "rel_idx": 3,
              "section": "Revenue Analysis",
              "title": "Q3 Financial Report"
            },
            "next_texts": [
              "The technology sector contributed 60% of total growth.",
              "Marketing expenses remained within budget projections."
            ],
            "object": "context.chunk",
            "previous_texts": [
              "Q3 FINANCIAL SUMMARY",
              "This report covers the third quarter performance metrics."
            ],
            "score": 0.856,
            "text": "Revenue increased by 15% compared to the previous quarter, primarily driven by strong performance in the technology sector."
          }
        ]
      },
      "ChunkedContentDocumentResponse": {
        "properties": {
          "artifact_id": {
            "type": "string",
            "title": "Artifact Id",
            "description": "Identifier of the document"
          },
          "content": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/TextBlock"
                },
                {
                  "$ref": "#/components/schemas/ImageBlock"
                },
                {
                  "$ref": "#/components/schemas/AudioBlock"
                },
                {
                  "$ref": "#/components/schemas/BinaryBlock"
                },
                {
                  "$ref": "#/components/schemas/ResourceLinkBlock"
                },
                {
                  "$ref": "#/components/schemas/ResourceBlock"
                },
                {
                  "$ref": "#/components/schemas/SourceBlock"
                },
                {
                  "$ref": "#/components/schemas/ToolUseBlock"
                },
                {
                  "$ref": "#/components/schemas/ThinkingBlock"
                },
                {
                  "$ref": "#/components/schemas/TLDRBlock"
                }
              ]
            },
            "type": "array",
            "title": "Content",
            "description": "Chunked content of the document, split into manageable pieces"
          }
        },
        "type": "object",
        "required": [
          "artifact_id",
          "content"
        ],
        "title": "ChunkedContentDocumentResponse",
        "description": "Response model for chunked document content."
      },
      "ChunkedContentResponse": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/ChunkedContentDocumentResponse"
            },
            "type": "array",
            "title": "Data",
            "description": "List of documents with their content split into chunks for chat usage"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "ChunkedContentResponse",
        "description": "Response containing chunked document content for chat usage."
      },
      "Citations": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Enable citations in responses",
            "default": false
          },
          "known_citations": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ZylonCitation"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Known Citations",
            "description": "List of known citations to use in the response"
          }
        },
        "type": "object",
        "title": "Citations",
        "description": "Configuration for citation generation in AI responses."
      },
      "ContentBody": {
        "properties": {
          "context_filter": {
            "$ref": "#/components/schemas/ContextFilter",
            "description": "Filter to select documents to retrieve. Supports filtering by collection, artifacts, and metadata."
          },
          "max_tokens": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Tokens",
            "description": "Maximum number of tokens to return in the content. If not set, returns full content of the documents."
          }
        },
        "type": "object",
        "required": [
          "context_filter"
        ],
        "title": "ContentBody",
        "description": "Request body for retrieving full document content with filtering options."
      },
      "ContentDocumentResponse": {
        "properties": {
          "artifact_id": {
            "type": "string",
            "title": "Artifact Id",
            "description": "Identifier of the document"
          },
          "content": {
            "type": "string",
            "title": "Content",
            "description": "Full text content of the document"
          }
        },
        "type": "object",
        "required": [
          "artifact_id",
          "content"
        ],
        "title": "ContentDocumentResponse",
        "description": "Individual document response with full content."
      },
      "ContentResponse": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/ContentDocumentResponse"
            },
            "type": "array",
            "title": "Data",
            "description": "List of documents with their full content"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "ContentResponse",
        "description": "Response containing full document content for filtered documents."
      },
      "ContextFilter": {
        "properties": {
          "collection": {
            "type": "string",
            "title": "Collection",
            "description": "The name of the collection to filter on.",
            "default": "pgpt_collection",
            "examples": [
              "collection_name"
            ]
          },
          "artifacts": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Artifacts",
            "description": "Artifacts ids to filter on.",
            "examples": [
              [
                "artifact_id_1, artifact_id_2"
              ]
            ]
          },
          "metadata_filter": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata Filter",
            "description": "Metadata filter to apply on the context.",
            "examples": [
              [
                {
                  "key": "file_id",
                  "operator": "==",
                  "value": "artifact_id_1"
                }
              ]
            ]
          }
        },
        "type": "object",
        "title": "ContextFilter",
        "description": "Filter by collection, artifacts and metadata in the ingested context.\n\nThe main filter is the collection the context is part of.\n\nAll artifacts ids are ensured to be part of the context. If any of the ids is not\nusable in the context (i.e. doesn't exist), the related task will fail.\n\nThe metadata filter will look for all context matching the metadata, if any, and\nadd it to the context. The filter is a dictionary of key-value pairs.\nThe key is the metadata key, and the value is the metadata value.\n\nIf both artifacts and metadata filters are provided, the result will be the\nintersection of the two filters."
      },
      "DatabaseQueryBody": {
        "properties": {
          "query": {
            "type": "string",
            "title": "Query",
            "description": "The natural language query to run against connected databases.",
            "examples": [
              "What were the Q4 revenue trends?"
            ]
          },
          "artifacts": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/FileArtifact"
                },
                {
                  "$ref": "#/components/schemas/UriArtifact"
                },
                {
                  "$ref": "#/components/schemas/TextArtifact"
                },
                {
                  "$ref": "#/components/schemas/IngestedArtifact"
                },
                {
                  "$ref": "#/components/schemas/SqlDatabaseArtifact"
                }
              ],
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "file": "#/components/schemas/FileArtifact",
                  "ingested_artifact": "#/components/schemas/IngestedArtifact",
                  "sql_database": "#/components/schemas/SqlDatabaseArtifact",
                  "text": "#/components/schemas/TextArtifact",
                  "uri": "#/components/schemas/UriArtifact"
                }
              }
            },
            "type": "array",
            "title": "Artifacts",
            "description": "List of SQL database artifacts to query against. At least one artifact of type 'sql_database' is required."
          }
        },
        "type": "object",
        "required": [
          "query",
          "artifacts"
        ],
        "title": "DatabaseQueryBody",
        "description": "Request body for database query using the tool."
      },
      "DeleteIngestedDocumentAsyncBody": {
        "properties": {
          "callback": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Callback"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional callback configuration for receiving asynchronous task notifications",
            "examples": [
              {
                "amqp": {
                  "exchange": "ingest",
                  "routing_key_done": "ingest.done",
                  "routing_key_error": "ingest.error"
                },
                "properties": {
                  "key": "value"
                }
              }
            ]
          },
          "delete_body": {
            "$ref": "#/components/schemas/DeleteIngestedDocumentBody",
            "description": "Document deletion parameters including collection and artifact identifiers"
          }
        },
        "type": "object",
        "required": [
          "delete_body"
        ],
        "title": "DeleteIngestedDocumentAsyncBody",
        "description": "Request body for asynchronous document deletion.",
        "examples": [
          {
            "callback": {
              "amqp": {
                "exchange": "deletion_events",
                "routing_key_done": "delete.completed",
                "routing_key_error": "delete.failed",
                "routing_key_progress": "delete.progress"
              }
            },
            "delete_body": {
              "artifact": "obsolete_report_2022",
              "collection": "financial_reports"
            }
          }
        ]
      },
      "DeleteIngestedDocumentBody": {
        "properties": {
          "collection": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Collection",
            "description": "Name of the collection containing the document to be deleted",
            "examples": [
              "financial_reports",
              "hr_documents"
            ]
          },
          "artifact": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Artifact",
            "description": "Unique identifier of the document to delete from the specified collection",
            "examples": [
              "quarterly_report_q1",
              "employee_handbook_2024"
            ]
          }
        },
        "type": "object",
        "required": [
          "collection",
          "artifact"
        ],
        "title": "DeleteIngestedDocumentBody",
        "description": "Request body for deleting specific ingested documents from the system.",
        "examples": [
          {
            "artifact": "q2_2023_report",
            "collection": "financial_reports"
          },
          {
            "artifact": "outdated_policy_manual",
            "collection": "hr_documents"
          }
        ]
      },
      "Embedding": {
        "properties": {
          "index": {
            "type": "integer",
            "title": "Index",
            "description": "Sequential index of this embedding in the batch, starting from 0",
            "examples": [
              0,
              1,
              2
            ]
          },
          "object": {
            "type": "string",
            "const": "embedding",
            "title": "Object",
            "description": "Type identifier for this object, always 'embedding'",
            "default": "embedding"
          },
          "embedding": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Embedding",
            "description": "High-dimensional vector representation of the text content as a list of floating-point numbers",
            "examples": [
              [
                0.0023064255,
                -0.009327292,
                0.0156234,
                -0.0087456
              ]
            ]
          }
        },
        "type": "object",
        "required": [
          "index",
          "embedding"
        ],
        "title": "Embedding",
        "description": "Represents a vector embedding for a piece of text content.",
        "examples": [
          {
            "embedding": [
              0.0023064255,
              -0.009327292,
              0.0156234,
              -0.0087456,
              0.0234567
            ],
            "index": 0,
            "object": "embedding"
          },
          {
            "embedding": [
              -0.0045123,
              0.0167845,
              -0.0098234,
              0.0134567,
              -0.0076543
            ],
            "index": 1,
            "object": "embedding"
          }
        ]
      },
      "EmbeddingsBody": {
        "properties": {
          "input": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Input",
            "description": "The text(s) to generate embeddings for. Can be a single string or an array of strings. Each text should be a meaningful unit of text (sentence, paragraph, etc).",
            "examples": [
              "The quick brown fox jumps over the lazy dog"
            ]
          }
        },
        "type": "object",
        "required": [
          "input"
        ],
        "title": "EmbeddingsBody",
        "description": "Request body for generating vector embeddings from text input.",
        "examples": [
          {
            "input": "The quick brown fox jumps over the lazy dog"
          },
          {
            "input": [
              "Machine learning is fascinating",
              "Neural networks process data efficiently",
              "Embeddings represent text as vectors"
            ]
          }
        ]
      },
      "EmbeddingsResponse": {
        "properties": {
          "object": {
            "type": "string",
            "const": "list",
            "title": "Object",
            "description": "The type of object returned",
            "default": "list"
          },
          "model": {
            "type": "string",
            "const": "private-gpt",
            "title": "Model",
            "description": "The model used to generate embeddings",
            "default": "private-gpt"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/Embedding"
            },
            "type": "array",
            "title": "Data",
            "description": "List of embeddings, one for each input text"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "EmbeddingsResponse",
        "description": "Response containing generated embeddings for input text(s)."
      },
      "FileArtifact": {
        "properties": {
          "type": {
            "type": "string",
            "const": "file",
            "title": "Type",
            "description": "Input type discriminator",
            "default": "file"
          },
          "value": {
            "type": "string",
            "title": "Value",
            "description": "Base64 encoded file content"
          }
        },
        "type": "object",
        "required": [
          "value"
        ],
        "title": "FileArtifact",
        "description": "Input for base64 encoded files."
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "HybridSearch": {
        "properties": {
          "type": {
            "type": "string",
            "const": "hybrid_search",
            "title": "Type",
            "description": "Type of search operation, always 'hybrid_search' for combined searches",
            "default": "hybrid_search"
          },
          "text": {
            "type": "string",
            "title": "Text",
            "description": "The text query to find relevant chunks",
            "examples": [
              "Q3 2023 sales"
            ]
          },
          "keywords": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Keywords",
            "description": "List of keywords to find relevant chunks",
            "examples": [
              [
                "sales",
                "Q3",
                "2023"
              ]
            ]
          },
          "context_filter": {
            "$ref": "#/components/schemas/ContextFilter",
            "description": "Filter to select specific context from ingested documents. Can filter by collection, artifacts, and metadata."
          },
          "limit": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of chunks to return",
            "default": 10
          },
          "expand": {
            "type": "boolean",
            "title": "Expand",
            "description": "Whether to include adjacent chunks for more context",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "text",
          "keywords",
          "context_filter"
        ],
        "title": "HybridSearch",
        "description": "Represents a hybrid search operation combining semantic and keyword search."
      },
      "ImageBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "image",
            "title": "Type",
            "description": "Content block type identifier for image content",
            "default": "image"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "data": {
            "type": "string",
            "title": "Data",
            "description": "Base64-encoded image data"
          },
          "mime_type": {
            "type": "string",
            "title": "Mime Type",
            "description": "MIME type of the image (e.g., 'image/png', 'image/jpeg')"
          }
        },
        "type": "object",
        "required": [
          "data",
          "mime_type"
        ],
        "title": "ImageBlock",
        "description": "Image content block containing visual media."
      },
      "IngestAsyncBody": {
        "properties": {
          "callback": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Callback"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional callback configuration for receiving asynchronous task notifications",
            "examples": [
              {
                "amqp": {
                  "exchange": "ingest",
                  "routing_key_done": "ingest.done",
                  "routing_key_error": "ingest.error"
                },
                "properties": {
                  "key": "value"
                }
              }
            ]
          },
          "ingest_body": {
            "$ref": "#/components/schemas/IngestBody",
            "description": "Document ingestion parameters including artifact, collection, input data, and optional metadata"
          }
        },
        "type": "object",
        "required": [
          "ingest_body"
        ],
        "title": "IngestAsyncBody",
        "description": "Request body for asynchronous URI ingestion.",
        "examples": [
          {
            "callback": {
              "amqp": {
                "exchange": "ingestion_events",
                "routing_key_done": "ingest.completed",
                "routing_key_error": "ingest.failed",
                "routing_key_progress": "ingest.progress"
              }
            },
            "ingest_body": {
              "artifact": "large_document_2024",
              "collection": "technical_docs",
              "input": {
                "type": "uri",
                "value": "https://example.com/docs/large-document.pdf"
              },
              "metadata": {
                "file_name": "large-document.pdf",
                "pages": 120,
                "size_mb": 45
              }
            }
          }
        ]
      },
      "IngestBody": {
        "properties": {
          "artifact": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Artifact",
            "description": "Unique identifier for the text being ingested within the collection",
            "examples": [
              "user_manual_chapter_1",
              "policy_document_2024"
            ]
          },
          "collection": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Collection",
            "description": "Collection name to group related documents for better organization and filtering",
            "default": "pgpt_collection",
            "examples": [
              "corporate_docs",
              "user_manuals",
              "financial_reports"
            ]
          },
          "input": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/FileArtifact"
              },
              {
                "$ref": "#/components/schemas/UriArtifact"
              },
              {
                "$ref": "#/components/schemas/TextArtifact"
              }
            ],
            "title": "Input",
            "description": "Raw input data to be processed and ingested into the system. Can be a file (base64), URI, or plain text",
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "file": "#/components/schemas/FileArtifact",
                "text": "#/components/schemas/TextArtifact",
                "uri": "#/components/schemas/UriArtifact"
              }
            }
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Optional metadata dictionary containing additional document information. If provided, must include 'file_name' with a valid file extension",
            "examples": [
              {
                "author": "John Doe",
                "department": "HR",
                "file_name": "company_policy.txt"
              },
              {
                "file_name": "manual_section.txt",
                "last_updated": "2024-01-15",
                "version": "2.1"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "artifact",
          "input"
        ],
        "title": "IngestBody",
        "description": "Request body for ingesting content into the system for AI context.",
        "examples": [
          {
            "artifact": "company_mission_statement",
            "collection": "corporate_docs",
            "input": {
              "type": "text",
              "value": "Our mission is to democratize access to artificial intelligence through secure, private, and user-controlled AI systems that respect data sovereignty and privacy."
            },
            "metadata": {
              "author": "CEO",
              "created_date": "2024-01-01",
              "department": "Executive",
              "file_name": "mission_statement.txt"
            }
          },
          {
            "artifact": "product_description",
            "collection": "marketing_materials",
            "input": {
              "type": "uri",
              "value": "https://cdn.example.com/reports/annual-2023.pdf"
            },
            "metadata": {
              "file_name": "product_desc.txt",
              "target_audience": "enterprise",
              "version": "1.0"
            }
          },
          {
            "artifact": "user_manual_chapter_1",
            "collection": "user_manuals",
            "input": {
              "type": "file",
              "value": "UEsDBBQABgAIAAAAIQDf3k5bAAAACgAAAHN0cmluZy50eHRVVQ=="
            },
            "metadata": {
              "author": "Jane Smith",
              "created_date": "2024-02-01",
              "file_name": "chapter_1.txt"
            }
          }
        ]
      },
      "IngestResponse": {
        "properties": {
          "object": {
            "type": "string",
            "const": "list",
            "title": "Object",
            "description": "Response object type, always 'list' for ingestion responses"
          },
          "model": {
            "type": "string",
            "const": "private-gpt",
            "title": "Model",
            "description": "Model identifier, always 'private-gpt'"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/IngestedDoc"
            },
            "type": "array",
            "title": "Data",
            "description": "List of ingested documents with their metadata and processing information"
          }
        },
        "type": "object",
        "required": [
          "object",
          "model",
          "data"
        ],
        "title": "IngestResponse",
        "description": "Response model for successful document ingestion operations.",
        "examples": [
          {
            "data": [
              {
                "artifact": "quarterly_report_q1",
                "doc_metadata": {
                  "department": "finance",
                  "file_name": "Q1_Report.pdf",
                  "page_number": 1,
                  "total_pages": 15
                },
                "object": "ingest.document"
              }
            ],
            "model": "private-gpt",
            "object": "list"
          }
        ]
      },
      "IngestedArtifact": {
        "properties": {
          "type": {
            "type": "string",
            "const": "ingested_artifact",
            "title": "Type",
            "description": "Input type discriminator",
            "default": "ingested_artifact"
          },
          "context_filter": {
            "$ref": "#/components/schemas/ContextFilter",
            "description": "Already processed ContextFilter"
          }
        },
        "type": "object",
        "required": [
          "context_filter"
        ],
        "title": "IngestedArtifact",
        "description": "Input for already ingested content."
      },
      "IngestedDoc": {
        "properties": {
          "object": {
            "type": "string",
            "const": "ingest.document",
            "title": "Object",
            "description": "Type of the object, indicating this is an ingested document.",
            "default": "ingest.document"
          },
          "artifact": {
            "type": "string",
            "title": "Artifact",
            "description": "Unique identifier for the ingested document artifact.",
            "examples": [
              "artifact_id_1"
            ]
          },
          "doc_metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Doc Metadata",
            "description": "Metadata associated with the ingested document, such as title, author, and other",
            "examples": [
              {
                "file_name": "Sales Report Q3 2023.pdf",
                "title": "Sales Report Q3 2023"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "artifact"
        ],
        "title": "IngestedDoc",
        "description": "Represents a document that has been ingested into the system."
      },
      "KeywordSearch": {
        "properties": {
          "type": {
            "type": "string",
            "const": "keywords_search",
            "title": "Type",
            "description": "Type of search operation, always 'keywords_search' for keyword searches",
            "default": "keywords_search"
          },
          "keywords": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Keywords",
            "description": "List of keywords to find relevant chunks",
            "examples": [
              [
                "sales",
                "Q3",
                "2023"
              ]
            ]
          },
          "context_filter": {
            "$ref": "#/components/schemas/ContextFilter",
            "description": "Filter to select specific context from ingested documents. Can filter by collection, artifacts, and metadata."
          },
          "limit": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of chunks to return",
            "default": 10
          }
        },
        "type": "object",
        "required": [
          "keywords",
          "context_filter"
        ],
        "title": "KeywordSearch",
        "description": "Represents a keyword-based search operation."
      },
      "McpServerConfig": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "A name for the MCP server configuration.",
            "default": "mcp"
          },
          "url": {
            "type": "string",
            "title": "Url",
            "description": "The URL of the MCP server to connect to."
          },
          "authorization_token": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authorization Token",
            "description": "The authorization token to use when connecting to the MCP server."
          },
          "tool_configuration": {
            "$ref": "#/components/schemas/McpServerToolConfig",
            "description": "Configuration for tool filtering from the MCP server"
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "title": "McpServerConfig",
        "description": "Configuration for the MCP server."
      },
      "McpServerToolConfig": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Enable tool filtering for the MCP server.",
            "default": true
          },
          "allowed_tools": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Allowed Tools",
            "description": "List of enabled tools to filter from the MCP server."
          }
        },
        "type": "object",
        "title": "McpServerToolConfig",
        "description": "Configuration for tool filtering from the MCP server."
      },
      "MessageInput": {
        "properties": {
          "role": {
            "type": "string",
            "enum": [
              "assistant",
              "user"
            ],
            "title": "Role",
            "description": "The role of the message sender",
            "default": "user"
          },
          "content": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/TextBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ImageBlock"
                    },
                    {
                      "$ref": "#/components/schemas/AudioBlock"
                    },
                    {
                      "$ref": "#/components/schemas/BinaryBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ResourceLinkBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ResourceBlock"
                    },
                    {
                      "$ref": "#/components/schemas/SourceBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ToolUseBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ThinkingBlock"
                    },
                    {
                      "$ref": "#/components/schemas/TLDRBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ToolResultBlock"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Content",
            "description": "The message content"
          }
        },
        "type": "object",
        "required": [
          "content"
        ],
        "title": "MessageInput",
        "description": "Input message for AI conversations."
      },
      "MessageOutput": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for this message response"
          },
          "type": {
            "type": "string",
            "const": "message",
            "title": "Type",
            "description": "Response type identifier indicating this is a message response",
            "default": "message"
          },
          "role": {
            "type": "string",
            "const": "assistant",
            "title": "Role",
            "description": "The role of the response sender, always 'assistant' for AI responses",
            "default": "assistant"
          },
          "content": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/TextBlock"
                },
                {
                  "$ref": "#/components/schemas/ImageBlock"
                },
                {
                  "$ref": "#/components/schemas/AudioBlock"
                },
                {
                  "$ref": "#/components/schemas/BinaryBlock"
                },
                {
                  "$ref": "#/components/schemas/ResourceLinkBlock"
                },
                {
                  "$ref": "#/components/schemas/ResourceBlock"
                },
                {
                  "$ref": "#/components/schemas/SourceBlock"
                },
                {
                  "$ref": "#/components/schemas/ToolUseBlock"
                },
                {
                  "$ref": "#/components/schemas/ThinkingBlock"
                },
                {
                  "$ref": "#/components/schemas/TLDRBlock"
                },
                {
                  "$ref": "#/components/schemas/ToolResultBlock"
                }
              ]
            },
            "type": "array",
            "title": "Content",
            "description": "List of content blocks that make up the AI's response",
            "default": []
          },
          "model": {
            "type": "string",
            "title": "Model",
            "description": "Identifier of the AI model used to generate this response",
            "default": "private-gpt"
          },
          "stop_reason": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StopReasonEnum"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reason why the AI stopped generating content"
          },
          "stop_sequence": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Sequence",
            "description": "The specific stop sequence that triggered response completion"
          },
          "usage": {
            "$ref": "#/components/schemas/Usage",
            "description": "Token usage statistics for this interaction"
          }
        },
        "type": "object",
        "title": "MessageOutput",
        "description": "AI response message with content and metadata."
      },
      "Resource": {
        "properties": {
          "uri": {
            "type": "string",
            "title": "Uri",
            "description": "URI/URL of the resource"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Human-readable name or title of the resource"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Optional description providing additional context about the resource"
          },
          "mime_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mime Type",
            "description": "MIME type of the resource, if known"
          }
        },
        "type": "object",
        "required": [
          "uri",
          "name"
        ],
        "title": "Resource",
        "description": "Resource metadata and information."
      },
      "ResourceBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "resource",
            "title": "Type",
            "description": "Content block type identifier for embedded resources",
            "default": "resource"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "resource": {
            "$ref": "#/components/schemas/Resource",
            "description": "The embedded resource information and metadata"
          }
        },
        "type": "object",
        "required": [
          "resource"
        ],
        "title": "ResourceBlock",
        "description": "Resource block containing embedded resource information."
      },
      "ResourceLinkBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "resource_link",
            "title": "Type",
            "description": "Content block type identifier for resource links",
            "default": "resource_link"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "uri": {
            "type": "string",
            "title": "Uri",
            "description": "URI/URL of the external resource being referenced"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Human-readable name or title of the resource"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Optional description providing additional context about the resource"
          },
          "mime_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mime Type",
            "description": "MIME type of the linked resource, if known"
          }
        },
        "type": "object",
        "required": [
          "uri",
          "name"
        ],
        "title": "ResourceLinkBlock",
        "description": "Resource link block referencing external resources."
      },
      "ResponseFormat": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ResponseFormatType",
            "description": "Response format type",
            "default": "text"
          },
          "json_schema": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Json Schema",
            "description": "JSON schema definition when type is 'json_schema'"
          }
        },
        "type": "object",
        "title": "ResponseFormat",
        "description": "Configuration for AI response formatting and structure."
      },
      "ResponseFormatType": {
        "type": "string",
        "enum": [
          "text",
          "json_schema"
        ],
        "title": "ResponseFormatType",
        "description": "Enumeration of supported response formats."
      },
      "SemanticSearch": {
        "properties": {
          "type": {
            "type": "string",
            "const": "semantic_search",
            "title": "Type",
            "description": "Type of search operation, always 'semantic_search' for semantic searches",
            "default": "semantic_search"
          },
          "text": {
            "type": "string",
            "title": "Text",
            "description": "The text query to find relevant chunks",
            "examples": [
              "Q3 2023 sales"
            ]
          },
          "context_filter": {
            "$ref": "#/components/schemas/ContextFilter",
            "description": "Filter to select specific context from ingested documents. Can filter by collection, artifacts, and metadata."
          },
          "limit": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of chunks to return",
            "default": 10
          },
          "score_threshold": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Score Threshold",
            "description": "Minimum similarity score threshold for returned chunks",
            "default": 0.0
          },
          "expand": {
            "type": "boolean",
            "title": "Expand",
            "description": "Whether to include adjacent chunks for more context",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "text",
          "context_filter"
        ],
        "title": "SemanticSearch",
        "description": "Represents a semantic search operation."
      },
      "SemanticSearchBody": {
        "properties": {
          "query": {
            "type": "string",
            "title": "Query",
            "description": "The natural language query to search for relevant content.",
            "examples": [
              "What were the Q4 revenue trends?"
            ]
          },
          "context_filter": {
            "$ref": "#/components/schemas/ContextFilter",
            "description": "Filters to narrow the search context (collections, artifacts, metadata)."
          },
          "format": {
            "type": "string",
            "enum": [
              "default",
              "citations"
            ],
            "title": "Format",
            "description": "Format of the result content.\n'default' returns standard content blocks.\n'citations' returns blocks annotated for citation formatting.",
            "default": "default",
            "examples": [
              "default"
            ]
          }
        },
        "type": "object",
        "required": [
          "query",
          "context_filter"
        ],
        "title": "SemanticSearchBody",
        "description": "Request body for semantic search."
      },
      "SourceBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "source",
            "title": "Type",
            "description": "Content block type identifier for source attribution",
            "default": "source"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "sources": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Chunk"
                },
                {
                  "$ref": "#/components/schemas/Website"
                }
              ]
            },
            "type": "array",
            "title": "Sources",
            "description": "List of document chunks that were used as context for generating the AI response"
          }
        },
        "type": "object",
        "required": [
          "sources"
        ],
        "title": "SourceBlock",
        "description": "Source block containing document chunks used for context."
      },
      "SqlDatabaseArtifact": {
        "properties": {
          "type": {
            "type": "string",
            "const": "sql_database",
            "title": "Type",
            "description": "Input type discriminator",
            "default": "sql_database"
          },
          "connection_string": {
            "type": "string",
            "title": "Connection String",
            "description": "SQL database connection string"
          },
          "schemas": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Schemas",
            "description": "List of specific schemas to include, if None includes all non-system schemas"
          },
          "ssl": {
            "type": "boolean",
            "title": "Ssl",
            "description": "Whether to use SSL for the database connection",
            "default": false
          },
          "enable_tables": {
            "type": "boolean",
            "title": "Enable Tables",
            "description": "Whether to include tables in the inspection",
            "default": true
          },
          "enable_views": {
            "type": "boolean",
            "title": "Enable Views",
            "description": "Whether to include views in the inspection",
            "default": true
          },
          "enable_functions": {
            "type": "boolean",
            "title": "Enable Functions",
            "description": "Whether to include functions in the inspection",
            "default": true
          },
          "enable_procedures": {
            "type": "boolean",
            "title": "Enable Procedures",
            "description": "Whether to include stored procedures in the inspection",
            "default": true
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description of the database",
            "default": ""
          }
        },
        "type": "object",
        "required": [
          "connection_string"
        ],
        "title": "SqlDatabaseArtifact",
        "description": "Input for SQL database content."
      },
      "StopReasonEnum": {
        "type": "string",
        "enum": [
          "end_turn",
          "max_tokens",
          "stop_sequence",
          "tool_use",
          "pause_turn",
          "refusal"
        ],
        "title": "StopReasonEnum",
        "description": "Enumeration for AI response stop reasons."
      },
      "StreamMetadata": {
        "properties": {
          "message_id": {
            "type": "string",
            "title": "Message Id",
            "description": "Unique identifier for the stream"
          },
          "status": {
            "$ref": "#/components/schemas/StreamStatus",
            "description": "Current status of the stream"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp when the stream was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Timestamp when the stream was last updated"
          },
          "completed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completed At",
            "description": "Timestamp when the stream was completed, if applicable"
          },
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error Message",
            "description": "Error message if the stream encountered an error"
          },
          "stream_type": {
            "type": "string",
            "title": "Stream Type",
            "description": "Type of the stream, used for categorization",
            "default": "default"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata associated with the stream"
          }
        },
        "type": "object",
        "required": [
          "message_id",
          "status",
          "created_at",
          "updated_at"
        ],
        "title": "StreamMetadata",
        "description": "Stream metadata and status information for asynchronous chat completions"
      },
      "StreamStatus": {
        "type": "string",
        "enum": [
          "pending",
          "processing",
          "completed",
          "failed",
          "cancelled",
          "error"
        ],
        "title": "StreamStatus",
        "description": "Enumeration of possible stream statuses."
      },
      "System": {
        "properties": {
          "use_default_prompt": {
            "type": "boolean",
            "title": "Use Default Prompt",
            "description": "When true, uses the default system prompt provided by Zylon",
            "default": false
          },
          "text": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Text",
            "description": "System prompt to use for the chat completion"
          },
          "citations": {
            "$ref": "#/components/schemas/Citations",
            "description": "Citation configuration for source attribution in responses",
            "default": {
              "enabled": false
            }
          },
          "extensions": {
            "items": {
              "$ref": "#/components/schemas/SystemExtensions"
            },
            "type": "array",
            "title": "Extensions",
            "description": "Set of enabled extensions"
          }
        },
        "type": "object",
        "title": "System",
        "description": "System message configuration for AI behavior and prompting."
      },
      "SystemExtensions": {
        "type": "string",
        "enum": [
          "zylon"
        ],
        "title": "SystemExtensions",
        "description": "Enumeration of supported system extensions."
      },
      "TLDRBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "tldr",
            "title": "Type",
            "description": "Content block type identifier for summary content",
            "default": "tldr"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "content": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/TextBlock"
                },
                {
                  "$ref": "#/components/schemas/ImageBlock"
                },
                {
                  "$ref": "#/components/schemas/AudioBlock"
                },
                {
                  "$ref": "#/components/schemas/BinaryBlock"
                },
                {
                  "$ref": "#/components/schemas/ResourceLinkBlock"
                },
                {
                  "$ref": "#/components/schemas/ResourceBlock"
                },
                {
                  "$ref": "#/components/schemas/SourceBlock"
                },
                {
                  "$ref": "#/components/schemas/ToolUseBlock"
                },
                {
                  "$ref": "#/components/schemas/ThinkingBlock"
                }
              ]
            },
            "type": "array",
            "title": "Content",
            "description": "List of content blocks that make up the summary or condensed information",
            "default": []
          }
        },
        "type": "object",
        "title": "TLDRBlock",
        "description": "Summary block containing condensed content."
      },
      "TabularDataAnalysisBody": {
        "properties": {
          "query": {
            "type": "string",
            "title": "Query",
            "description": "The analysis question or prompt related to tabular data.",
            "examples": [
              "Show average revenue by department over the last 3 quarters."
            ]
          },
          "context_filter": {
            "$ref": "#/components/schemas/ContextFilter",
            "description": "Filters to select specific context from ingested documents."
          }
        },
        "type": "object",
        "required": [
          "query",
          "context_filter"
        ],
        "title": "TabularDataAnalysisBody",
        "description": "Request body for tabular data analysis using the tool."
      },
      "Task": {
        "properties": {
          "task_id": {
            "type": "string",
            "title": "Task Id",
            "description": "Unique identifier for the asynchronous task, used to track progress and retrieve results",
            "examples": [
              "123e4567-e89b-12d3-a456-426614174000",
              "revoked"
            ]
          }
        },
        "type": "object",
        "required": [
          "task_id"
        ],
        "title": "Task",
        "description": "Represents an asynchronous task that has been queued.",
        "examples": [
          {
            "task_id": "123e4567-e89b-12d3-a456-426614174000"
          },
          {
            "task_id": "456e7890-e89b-12d3-a456-426614174001"
          }
        ]
      },
      "TaskStatus_IngestResponse_": {
        "properties": {
          "task_id": {
            "type": "string",
            "title": "Task Id",
            "description": "Unique identifier of the task being monitored",
            "examples": [
              "123e4567-e89b-12d3-a456-426614174000"
            ]
          },
          "task_status": {
            "type": "string",
            "title": "Task Status",
            "description": "Current execution status of the task. Common values: PENDING, SUCCESS, FAILURE, REVOKED",
            "examples": [
              "PENDING",
              "SUCCESS",
              "FAILURE",
              "REVOKED"
            ]
          },
          "task_result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/IngestResponse"
              },
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Task Result",
            "description": "Task execution result. Contains typed result data on success, error message string on failure, or None for pending/deletion tasks",
            "examples": [
              null,
              "File format not supported",
              {
                "data": [],
                "model": "private-gpt",
                "object": "list"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "task_id",
          "task_status",
          "task_result"
        ],
        "title": "TaskStatus[IngestResponse]",
        "description": "Represents the status of an asynchronous task, including its ID, status, and result.",
        "examples": [
          {
            "task_id": "123e4567-e89b-12d3-a456-426614174000",
            "task_result": {
              "data": [
                {
                  "artifact": "annual_report",
                  "doc_metadata": {
                    "file_name": "report.pdf",
                    "pages": 45
                  },
                  "object": "ingest.document"
                }
              ],
              "model": "private-gpt",
              "object": "list"
            },
            "task_status": "SUCCESS"
          },
          {
            "task_id": "456e7890-e89b-12d3-a456-426614174001",
            "task_status": "PENDING"
          },
          {
            "task_id": "789e0123-e89b-12d3-a456-426614174002",
            "task_result": "URI resource could not be accessed",
            "task_status": "FAILURE"
          }
        ]
      },
      "TaskStatus_NoneType_": {
        "properties": {
          "task_id": {
            "type": "string",
            "title": "Task Id",
            "description": "Unique identifier of the task being monitored",
            "examples": [
              "123e4567-e89b-12d3-a456-426614174000"
            ]
          },
          "task_status": {
            "type": "string",
            "title": "Task Status",
            "description": "Current execution status of the task. Common values: PENDING, SUCCESS, FAILURE, REVOKED",
            "examples": [
              "PENDING",
              "SUCCESS",
              "FAILURE",
              "REVOKED"
            ]
          },
          "task_result": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Task Result",
            "description": "Task execution result. Contains typed result data on success, error message string on failure, or None for pending/deletion tasks",
            "examples": [
              null,
              "File format not supported",
              {
                "data": [],
                "model": "private-gpt",
                "object": "list"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "task_id",
          "task_status",
          "task_result"
        ],
        "title": "TaskStatus[NoneType]",
        "description": "Represents the status of an asynchronous task, including its ID, status, and result.",
        "examples": [
          {
            "task_id": "123e4567-e89b-12d3-a456-426614174000",
            "task_result": {
              "data": [
                {
                  "artifact": "annual_report",
                  "doc_metadata": {
                    "file_name": "report.pdf",
                    "pages": 45
                  },
                  "object": "ingest.document"
                }
              ],
              "model": "private-gpt",
              "object": "list"
            },
            "task_status": "SUCCESS"
          },
          {
            "task_id": "456e7890-e89b-12d3-a456-426614174001",
            "task_status": "PENDING"
          },
          {
            "task_id": "789e0123-e89b-12d3-a456-426614174002",
            "task_result": "URI resource could not be accessed",
            "task_status": "FAILURE"
          }
        ]
      },
      "TextArtifact": {
        "properties": {
          "type": {
            "type": "string",
            "const": "text",
            "title": "Type",
            "description": "Input type discriminator",
            "default": "text"
          },
          "value": {
            "type": "string",
            "title": "Value",
            "description": "Plain text content"
          }
        },
        "type": "object",
        "required": [
          "value"
        ],
        "title": "TextArtifact",
        "description": "Input for plain text content."
      },
      "TextBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "text",
            "title": "Type",
            "description": "Content block type identifier for text content",
            "default": "text"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "text": {
            "type": "string",
            "title": "Text",
            "description": "The natural language text content of this block",
            "default": ""
          },
          "citations": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ZylonCitation"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Citations",
            "description": "List of citations referencing sources used to generate this text",
            "default": []
          }
        },
        "type": "object",
        "title": "TextBlock",
        "description": "Text content block containing natural language text."
      },
      "Thinking": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Enable reasoning capabilities for the model, allowing it to think step-by-step",
            "default": false
          }
        },
        "type": "object",
        "title": "Thinking",
        "description": "Configuration for AI reasoning and step-by-step thinking capabilities."
      },
      "ThinkingBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "thinking",
            "title": "Type",
            "description": "Content block type identifier for reasoning content",
            "default": "thinking"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "thinking": {
            "type": "string",
            "title": "Thinking",
            "description": "The AI's step-by-step reasoning and thought process",
            "default": ""
          },
          "citations": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ZylonCitation"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Citations",
            "description": "List of citations referencing sources used during the reasoning process",
            "default": []
          }
        },
        "type": "object",
        "title": "ThinkingBlock",
        "description": "Thinking block containing the AI's reasoning process."
      },
      "ToolChoice": {
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "auto",
              "tool",
              "none"
            ],
            "title": "Type",
            "description": "Tool selection strategy",
            "default": "auto"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Name of the tool to use if not auto-selecting"
          },
          "disable_parallel_tool_use": {
            "type": "boolean",
            "title": "Disable Parallel Tool Use",
            "description": "When true, prevents the AI from using multiple tools simultaneously",
            "default": false
          },
          "validation_mode": {
            "type": "string",
            "enum": [
              "eager",
              "lazy"
            ],
            "title": "Validation Mode",
            "description": "Tool validation mode. 'eager' validates tool calls before execution, 'lazy' validates if tool call is made.",
            "default": "lazy"
          }
        },
        "type": "object",
        "title": "ToolChoice",
        "description": "Configuration for tool selection behavior during AI interactions."
      },
      "ToolResponse": {
        "properties": {
          "content": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/TextBlock"
                },
                {
                  "$ref": "#/components/schemas/ImageBlock"
                },
                {
                  "$ref": "#/components/schemas/AudioBlock"
                },
                {
                  "$ref": "#/components/schemas/BinaryBlock"
                },
                {
                  "$ref": "#/components/schemas/ResourceLinkBlock"
                },
                {
                  "$ref": "#/components/schemas/ResourceBlock"
                },
                {
                  "$ref": "#/components/schemas/SourceBlock"
                },
                {
                  "$ref": "#/components/schemas/ToolUseBlock"
                },
                {
                  "$ref": "#/components/schemas/ThinkingBlock"
                },
                {
                  "$ref": "#/components/schemas/TLDRBlock"
                }
              ]
            },
            "type": "array",
            "title": "Content",
            "description": "List of content blocks generated by the tool. Blocks can include plain text, citations, source attributions, or images."
          },
          "is_error": {
            "type": "boolean",
            "title": "Is Error",
            "description": "True if the tool encountered an error during execution.",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "content"
        ],
        "title": "ToolResponse",
        "description": "Response returned from tool-based operations."
      },
      "ToolResultBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "tool_result",
            "title": "Type",
            "description": "Content block type identifier for tool results",
            "default": "tool_result"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "tool_use_id": {
            "type": "string",
            "title": "Tool Use Id",
            "description": "ID of the corresponding tool use block that generated this result"
          },
          "content": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/TextBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ImageBlock"
                    },
                    {
                      "$ref": "#/components/schemas/AudioBlock"
                    },
                    {
                      "$ref": "#/components/schemas/BinaryBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ResourceLinkBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ResourceBlock"
                    },
                    {
                      "$ref": "#/components/schemas/SourceBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ToolUseBlock"
                    },
                    {
                      "$ref": "#/components/schemas/ThinkingBlock"
                    },
                    {
                      "$ref": "#/components/schemas/TLDRBlock"
                    }
                  ]
                },
                "type": "array"
              }
            ],
            "title": "Content",
            "description": "The result content from the tool execution"
          },
          "is_error": {
            "type": "boolean",
            "title": "Is Error",
            "description": "Indicates whether the tool execution resulted in an error",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "tool_use_id",
          "content"
        ],
        "title": "ToolResultBlock",
        "description": "Tool result block containing the output from a tool execution."
      },
      "ToolSpec": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique name identifier for the tool"
          },
          "type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Type",
            "description": "Type of the tool, use to identify internal tools database_query_v1 or semantic_search_v2"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Human-readable description of what the tool does"
          },
          "inputSchema": {
            "additionalProperties": true,
            "type": "object",
            "title": "Inputschema",
            "description": "JSON schema defining the input parameters the tool accepts"
          },
          "context": {
            "anyOf": [
              {
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/FileArtifact"
                    },
                    {
                      "$ref": "#/components/schemas/UriArtifact"
                    },
                    {
                      "$ref": "#/components/schemas/TextArtifact"
                    },
                    {
                      "$ref": "#/components/schemas/IngestedArtifact"
                    },
                    {
                      "$ref": "#/components/schemas/SqlDatabaseArtifact"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "file": "#/components/schemas/FileArtifact",
                      "ingested_artifact": "#/components/schemas/IngestedArtifact",
                      "sql_database": "#/components/schemas/SqlDatabaseArtifact",
                      "text": "#/components/schemas/TextArtifact",
                      "uri": "#/components/schemas/UriArtifact"
                    }
                  }
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Context",
            "description": "Additional context or metadata for the tool"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "name"
        ],
        "title": "ToolSpec",
        "description": "Definition for a tool the client can call."
      },
      "ToolUseBlock": {
        "properties": {
          "type": {
            "type": "string",
            "const": "tool_use",
            "title": "Type",
            "description": "Content block type identifier for tool usage",
            "default": "tool_use"
          },
          "start_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Timestamp",
            "description": "ISO timestamp when content block generation started"
          },
          "stop_timestamp": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stop Timestamp",
            "description": "ISO timestamp when content block generation completed"
          },
          "_meta": {
            "additionalProperties": true,
            "type": "object",
            "title": "Meta",
            "description": "Additional metadata associated with this content block"
          },
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for this tool use"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the tool being called"
          },
          "input": {
            "additionalProperties": true,
            "type": "object",
            "title": "Input",
            "description": "Input parameters passed to the tool",
            "default": {}
          }
        },
        "type": "object",
        "required": [
          "id",
          "name"
        ],
        "title": "ToolUseBlock",
        "description": "Tool usage block representing an AI's call to a tool."
      },
      "UriArtifact": {
        "properties": {
          "type": {
            "type": "string",
            "const": "uri",
            "title": "Type",
            "description": "Input type discriminator",
            "default": "uri"
          },
          "value": {
            "type": "string",
            "title": "Value",
            "description": "URI to download from"
          }
        },
        "type": "object",
        "required": [
          "value"
        ],
        "title": "UriArtifact",
        "description": "Input for remote URIs."
      },
      "Usage": {
        "properties": {
          "input_tokens": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input Tokens",
            "description": "Number of tokens consumed from the input (prompt and context)"
          },
          "output_tokens": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Output Tokens",
            "description": "Number of tokens generated in the output (AI response)"
          }
        },
        "type": "object",
        "title": "Usage",
        "description": "Token usage statistics for AI interactions."
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "WebFetchBody": {
        "properties": {
          "url": {
            "type": "string",
            "title": "Url",
            "description": "The URL of the web page to fetch and extract content from.",
            "examples": [
              "https://example.com/article"
            ]
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "title": "WebFetchBody",
        "description": "Request body for web content fetching using the tool."
      },
      "WebSearchQueryBody": {
        "properties": {
          "query": {
            "type": "string",
            "title": "Query",
            "description": "The natural language query to search the web.",
            "examples": [
              "Latest news on AI advancements"
            ]
          }
        },
        "type": "object",
        "required": [
          "query"
        ],
        "title": "WebSearchQueryBody",
        "description": "Request body for web search using the tool."
      },
      "Website": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the website source",
            "examples": [
              "website_123e4567-e89b-12d3-a456-426614174000"
            ]
          },
          "object": {
            "type": "string",
            "const": "context.website",
            "title": "Object",
            "description": "Object type identifier, always 'context.website' for website sources"
          },
          "url": {
            "type": "string",
            "title": "Url",
            "description": "The URL of the website",
            "examples": [
              "https://www.example.com",
              "https://docs.privategpt.com/getting-started",
              "https://en.wikipedia.org/wiki/Artificial_intelligence"
            ]
          },
          "favicon_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Favicon Url",
            "description": "The URL of the website's favicon",
            "examples": [
              "https://www.example.com/favicon.ico",
              "https://docs.privategpt.com/favicon.png",
              "https://en.wikipedia.org/static/favicon/wikipedia.ico"
            ]
          },
          "title": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Title",
            "description": "The title of the website or webpage",
            "examples": [
              "Example Domain",
              "Getting Started with PrivateGPT - Documentation",
              "Artificial Intelligence - Wikipedia"
            ]
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "A brief description or summary of the website content",
            "examples": [
              "This domain is for use in illustrative examples in documents.",
              "PrivateGPT is an open-source project that enables private AI interactions.",
              "Artificial intelligence (AI) is intelligence demonstrated by machines."
            ]
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional metadata about the website source",
            "examples": [
              {
                "accessed_date": "2024-01-15",
                "language": "en"
              },
              {
                "accessed_date": "2024-02-20",
                "language": "fr"
              },
              null
            ]
          },
          "content_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Content Type",
            "description": "MIME type indicating the format of the website content",
            "examples": [
              "text/html",
              "application/json"
            ]
          },
          "content": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Content",
            "description": "The actual text content extracted from the website",
            "examples": [
              "<html><head><title>Example Domain</title></head><body>This domain is for use in illustrative examples in documents.</body></html>",
              "PrivateGPT is an open-source project that enables private AI interactions.",
              "Artificial intelligence (AI) is intelligence demonstrated by machines."
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "object",
          "url"
        ],
        "title": "Website",
        "description": "Represents a website URL source."
      },
      "ZylonCitation": {
        "properties": {
          "id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Id",
            "description": "Unique identifier for the citation"
          },
          "index": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Index",
            "description": "Index of the citation in the document"
          },
          "artifact_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Artifact Id",
            "description": "Identifier of the artifact associated with the citation"
          },
          "source_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Id",
            "description": "Identifier of the source document from which the citation is derived"
          }
        },
        "type": "object",
        "title": "ZylonCitation",
        "description": "ZylonCitation represents a citation in the Zylon format."
      }
    }
  }
}